{"version":3,"file":"calculator-OopdbshB.js","sources":["../../src/modules/calculator.ts"],"sourcesContent":["// ========================================\n// MegaBonk Breakpoint Calculator Module\n// ========================================\n\nimport type { Item } from '../types/index.ts';\nimport { safeSetValue } from './utils.ts';\nimport { logger } from './logger.ts';\nimport { allData } from './data-service.ts';\nimport { callFunction } from './registry.ts';\nimport { ToastManager } from './toast.ts';\n\n// ========================================\n// Type Definitions\n// ========================================\n\n/**\n * Calculator result structure\n */\ninterface CalculatorResult {\n    itemName: string;\n    perStack: number;\n    targetValue: number;\n    stacksNeeded: number;\n    formula: string;\n    scalingType: string;\n    stackCap?: number;\n    oneAndDone?: boolean;\n    stacksWell?: boolean;\n    scalingPerStack: number[];\n}\n\n/**\n * Pure calculation result (for testing)\n */\nexport interface BreakpointResult {\n    error?: string;\n    item?: Item;\n    target?: number;\n    stacksNeeded?: number;\n    perStack?: number;\n    actualValue?: number;\n    isCapped?: boolean;\n    isOneAndDone?: boolean;\n    hasWarning?: boolean;\n}\n\n/**\n * Data structure expected by computeBreakpoint\n */\nexport interface BreakpointData {\n    items?: {\n        items: Item[];\n    };\n}\n\n// ========================================\n// Pure Calculation Functions (Testable)\n// ========================================\n\n/**\n * Pure function to compute breakpoint calculation\n * This function has no side effects and can be easily unit tested\n * @param data - Data containing items array\n * @param itemId - Item ID to calculate for\n * @param target - Target value to reach\n * @returns Breakpoint calculation result\n */\nexport function computeBreakpoint(data: BreakpointData, itemId: string, target: number): BreakpointResult {\n    if (!itemId || !target || target <= 0) {\n        return { error: 'Please select an item and enter a target value!' };\n    }\n\n    const item = data.items?.items.find((i: Item) => i.id === itemId);\n    if (!item) {\n        return { error: 'Item not found' };\n    }\n\n    if (!item.scaling_per_stack || item.scaling_per_stack.length === 0) {\n        return { error: 'Item has no scaling data' };\n    }\n\n    // Calculate stacks needed\n    let stacksNeeded = 0;\n    const firstValue = item.scaling_per_stack[0] ?? null;\n\n    // Validate that first value is a valid positive number\n    // Handle null, undefined, NaN, non-numeric values, and zero/negative\n    if (firstValue === null || typeof firstValue !== 'number' || !Number.isFinite(firstValue) || firstValue <= 0) {\n        return { error: 'Invalid scaling value' };\n    }\n\n    const perStack = firstValue;\n    stacksNeeded = Math.ceil(target / perStack);\n\n    // Cap checks\n    const isCapped = item.stack_cap != null && stacksNeeded > item.stack_cap;\n    if (isCapped) {\n        stacksNeeded = item.stack_cap!;\n    }\n\n    // Calculate actual value achieved\n    const actualValue = stacksNeeded * perStack;\n\n    // Determine if there are warnings to show\n    const isOneAndDone = item.one_and_done === true;\n    const doesNotStackWell = item.stacks_well === false;\n    const hasWarning = isOneAndDone || doesNotStackWell || isCapped;\n\n    return {\n        item: item,\n        target: target,\n        stacksNeeded: stacksNeeded,\n        perStack: perStack,\n        actualValue: actualValue,\n        isCapped: isCapped,\n        isOneAndDone: isOneAndDone,\n        hasWarning: hasWarning,\n    };\n}\n\n// ========================================\n// Exported Functions\n// ========================================\n\n/**\n * Populate calculator items dropdown\n */\nexport function populateCalculatorItems(): void {\n    const select = document.getElementById('calc-item-select') as HTMLSelectElement | null;\n    if (!select || !allData.items?.items) {\n        return; // Calculator not ready\n    }\n\n    // Clear existing options except the first (placeholder)\n    while (select.options.length > 1) {\n        select.remove(1);\n    }\n\n    // Add items with scaling_per_stack data\n    const scalingItems = allData.items.items.filter((item: Item) => {\n        return item.scaling_per_stack && item.scaling_per_stack.length > 0;\n    });\n\n    scalingItems.forEach((item: Item) => {\n        const option = document.createElement('option');\n        option.value = item.id;\n        option.textContent = item.name;\n        select.appendChild(option);\n    });\n}\n\n/**\n * Calculate breakpoint for an item\n */\nexport function calculateBreakpoint(): void {\n    const select = document.getElementById('calc-item-select') as HTMLSelectElement | null;\n    const input = document.getElementById('calc-target') as HTMLInputElement | null;\n    const resultDiv = document.getElementById('calc-result');\n\n    if (!select || !input || !resultDiv) {\n        return; // Calculator elements not ready\n    }\n\n    const itemId = select.value;\n    const target = parseFloat(input.value);\n\n    if (!itemId) {\n        resultDiv.style.display = 'none';\n        return;\n    }\n\n    if (isNaN(target) || target <= 0) {\n        ToastManager.warning('Please enter a valid target value');\n        return;\n    }\n\n    // Find item\n    const item = allData.items?.items?.find((i: Item) => i.id === itemId);\n    if (!item || !item.scaling_per_stack || item.scaling_per_stack.length === 0) {\n        ToastManager.error('Item not found or has no scaling data');\n        return;\n    }\n\n    // Calculate stacks needed\n    let stacksNeeded = 0;\n    const perStack = item.scaling_per_stack[0] ?? null; // Value per stack from first entry\n\n    // Check for division by zero and validate perStack is a valid number\n    // Handle null, undefined, NaN, non-numeric values, and zero/negative\n    if (perStack === null || typeof perStack !== 'number' || !Number.isFinite(perStack) || perStack <= 0) {\n        ToastManager.warning('Invalid scaling value for this item');\n        return;\n    }\n\n    stacksNeeded = Math.ceil(target / perStack);\n\n    // Bug fix: Track if original calculation exceeded cap BEFORE capping\n    // Using === only checks if final value equals cap, not if we were limited\n    const isCapped = item.stack_cap != null && stacksNeeded > item.stack_cap;\n\n    // Cap checks\n    if (isCapped) {\n        stacksNeeded = item.stack_cap!;\n    }\n    const actualValue = stacksNeeded * perStack;\n\n    // Display result\n    const result: CalculatorResult = {\n        itemName: item.name,\n        perStack: perStack,\n        targetValue: target,\n        stacksNeeded: stacksNeeded,\n        formula: item.formula || 'No formula available',\n        scalingType: item.scaling_type || '',\n        stackCap: item.stack_cap,\n        oneAndDone: item.one_and_done,\n        stacksWell: item.stacks_well,\n        scalingPerStack: item.scaling_per_stack,\n    };\n\n    // Log calculator event\n    logger.info({\n        operation: 'calculator.compute',\n        success: true,\n        data: {\n            itemId: item.id,\n            itemName: item.name,\n            targetValue: target,\n            result: {\n                stacksNeeded,\n                perStack,\n                actualValue,\n                isCapped,\n                isOneAndDone: item.one_and_done === true,\n            },\n        },\n    });\n\n    renderResults(result);\n}\n\n/**\n * Render calculation results\n * @param result - Calculation result\n */\nfunction renderResults(result: CalculatorResult): void {\n    const resultDiv = document.getElementById('calc-result');\n    if (!resultDiv) return;\n\n    const isPercentage = result.scalingType.includes('chance') || result.scalingType.includes('percentage');\n    const unit = isPercentage ? '%' : '';\n\n    // Bug fix: Trim scaling array to stack_cap to avoid showing bars beyond the cap\n    // Bug fix: Ensure stack_cap is positive before using it with slice()\n    // slice(0, negative) removes elements from the end, which is not intended\n    const effectiveScaling = result.stackCap && result.stackCap > 0\n        ? result.scalingPerStack.slice(0, result.stackCap)\n        : result.scalingPerStack;\n\n    // Calculate max for bar graph normalization\n    const maxVal = effectiveScaling.length > 0 ? Math.max(...effectiveScaling) : 1;\n    const safeMax = maxVal > 0 ? maxVal : 1;\n\n    const barGraphHTML = effectiveScaling\n        .map((val: number, idx: number) => {\n            const height = (val / safeMax) * 100;\n            // Bug fix: Highlight the target bar, or the last available bar if\n            // stacksNeeded exceeds available data points (sparse scaling data)\n            const isTarget =\n                idx + 1 === result.stacksNeeded ||\n                (result.stacksNeeded > effectiveScaling.length && idx === effectiveScaling.length - 1);\n            return `<div class=\"bar-container\">\n                        <div class=\"bar ${isTarget ? 'highlight' : ''}\" style=\"height: ${height}%\"></div>\n                        <div class=\"bar-label\">${idx + 1}</div>\n                    </div>`;\n        })\n        .join('');\n\n    resultDiv.style.display = 'block';\n    resultDiv.innerHTML = `\n        <div class=\"calc-result-content\">\n            <h3>üìä Calculation Result</h3>\n            <div class=\"result-main\">\n                <div class=\"result-item\">\n                    <div class=\"result-label\">Item:</div>\n                    <div class=\"result-value\"><strong>${result.itemName}</strong></div>\n                </div>\n                <div class=\"result-item\">\n                    <div class=\"result-label\">Target Value:</div>\n                    <div class=\"result-value\"><strong>${result.targetValue}${unit}</strong></div>\n                </div>\n                <div class=\"result-item highlight\">\n                    <div class=\"result-label\">Stacks Needed:</div>\n                    <div class=\"result-value large\"><strong>${result.stacksNeeded}</strong></div>\n                </div>\n            </div>\n\n            <div class=\"result-details\">\n                <p><strong>Formula:</strong> ${result.formula}</p>\n                <p><strong>Per Stack:</strong> +${result.perStack}${unit}</p>\n                ${result.stackCap ? `<p class=\"warning\">‚ö†Ô∏è Note: This item caps at ${result.stackCap} stacks</p>` : ''}\n                ${result.oneAndDone ? `<p class=\"warning\">‚ö†Ô∏è Note: This is a one-and-done item - additional copies provide no benefit!</p>` : ''}\n                ${result.stacksWell === false ? `<p class=\"warning\">‚ö†Ô∏è Note: This item has diminishing returns or limited stacking</p>` : ''}\n            </div>\n\n            <div class=\"result-graph\">\n                <h4>Scaling Visualization (1-${effectiveScaling.length} stacks${result.stackCap ? `, capped at ${result.stackCap}` : ''})</h4>\n                <div class=\"mini-bar-graph\">\n                    ${barGraphHTML}\n                </div>\n            </div>\n        </div>\n    `;\n}\n\n/**\n * Quick calculate from item card\n * @param itemId - Item ID\n * @param target - Target value (optional)\n */\nexport function quickCalc(itemId: string, target?: number): void {\n    // Switch to calculator tab using registry (avoids circular dependency)\n    callFunction('switchTab', 'calculator');\n\n    // Set item\n    safeSetValue('calc-item-select', itemId);\n\n    // Set target if provided\n    if (target !== undefined && target > 0) {\n        safeSetValue('calc-target', target.toString());\n        // Auto-calculate\n        setTimeout(() => {\n            calculateBreakpoint();\n        }, 100);\n    }\n}\n"],"names":["computeBreakpoint","data","itemId","target","error","item","items","find","i","id","scaling_per_stack","length","stacksNeeded","firstValue","Number","isFinite","perStack","Math","ceil","isCapped","stack_cap","actualValue","isOneAndDone","one_and_done","doesNotStackWell","stacks_well","hasWarning","populateCalculatorItems","select","document","getElementById","allData","options","remove","filter","forEach","option","createElement","value","textContent","name","appendChild","calculateBreakpoint","input","resultDiv","parseFloat","style","display","isNaN","ToastManager","warning","result","itemName","targetValue","formula","scalingType","scaling_type","stackCap","oneAndDone","stacksWell","scalingPerStack","logger","info","operation","success","isPercentage","includes","unit","effectiveScaling","slice","maxVal","max","safeMax","barGraphHTML","map","val","idx","height","join","innerHTML","renderResults","quickCalc","callFunction","safeSetValue","toString","setTimeout"],"mappings":"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"}