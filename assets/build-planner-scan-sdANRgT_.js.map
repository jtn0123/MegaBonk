{"version":3,"file":"build-planner-scan-sdANRgT_.js","sources":["../../src/modules/cv/grid-analysis.ts","../../src/modules/cv/grid-validation.ts","../../src/modules/cv/auto-grid-detection.ts","../../src/modules/build-planner-scan.ts"],"sourcesContent":["// ========================================\n// Grid Analysis - Core Detection Algorithms\n// Hotbar band detection, border detection, icon metrics\n// ========================================\n\nimport { detectRarityAtPixel } from './color.ts';\nimport type {\n    AutoGridConfig,\n    BandRegion,\n    BorderResult,\n    CellEdge,\n    GridCalibration,\n    GridPosition,\n    GridResult,\n    IconMetrics,\n    RawEdge,\n    StripData,\n} from './grid-types.ts';\n\n// ========================================\n// Pass 1: Hotbar Band Detection\n// ========================================\n\n/**\n * Detect the hotbar band region at the bottom of the screen\n * Returns the Y coordinates where the item bar exists\n */\nexport function detectHotbarBand(ctx: CanvasRenderingContext2D, width: number, height: number): BandRegion {\n    // Scan bottom 30% of screen (hotbar is usually at very bottom)\n    const scanStartY = Math.floor(height * 0.7);\n\n    // Only sample center 70% of width (where hotbar items are, avoiding UI edges)\n    const sampleStartX = Math.floor(width * 0.15);\n    const sampleWidth = Math.floor(width * 0.7);\n\n    // Analyze horizontal strips\n    const stripData: StripData[] = [];\n    const stripHeight = 2; // Sample every 2 pixels for speed\n\n    for (let y = scanStartY; y < height - stripHeight; y += stripHeight) {\n        const imageData = ctx.getImageData(sampleStartX, y, sampleWidth, stripHeight);\n        const pixels = imageData.data;\n\n        let totalBrightness = 0;\n        let totalVariance = 0;\n        let colorfulPixels = 0;\n        let rarityBorderPixels = 0;\n        let count = 0;\n\n        // Sample across the strip\n        for (let i = 0; i < pixels.length; i += 16) {\n            // Sample every 4th pixel\n            const r = pixels[i] ?? 0;\n            const g = pixels[i + 1] ?? 0;\n            const b = pixels[i + 2] ?? 0;\n\n            const brightness = (r + g + b) / 3;\n            totalBrightness += brightness;\n\n            // Color variance (how different are RGB channels)\n            const mean = brightness;\n            const variance = Math.pow(r - mean, 2) + Math.pow(g - mean, 2) + Math.pow(b - mean, 2);\n            totalVariance += variance;\n\n            // Count colorful pixels (potential rarity borders)\n            const saturation = Math.max(r, g, b) - Math.min(r, g, b);\n            if (saturation > 50) colorfulPixels++;\n\n            // Count actual rarity border color matches (more specific)\n            if (detectRarityAtPixel(r, g, b)) {\n                rarityBorderPixels++;\n            }\n\n            count++;\n        }\n\n        stripData.push({\n            y,\n            avgBrightness: totalBrightness / count,\n            avgVariance: totalVariance / count,\n            colorfulRatio: colorfulPixels / count,\n            rarityRatio: rarityBorderPixels / count,\n        });\n    }\n\n    // Find the hotbar band by looking for:\n    // 1. Region with moderate brightness (not too dark, not too bright)\n    // 2. Higher color variance (icons are colorful)\n    // 3. Some colorful pixels (rarity borders)\n\n    let bestBandStart = -1;\n    let bestBandEnd = height;\n    let bestScore = 0;\n\n    // Window size: 35 strips Ã— 2px = ~70px to capture full icon height\n    const windowSize = 35;\n\n    for (let i = 0; i < stripData.length - windowSize; i++) {\n        const windowSlice = stripData.slice(i, i + windowSize);\n\n        const avgBrightness = windowSlice.reduce((s, d) => s + d.avgBrightness, 0) / windowSlice.length;\n        const avgVariance = windowSlice.reduce((s, d) => s + d.avgVariance, 0) / windowSlice.length;\n        const avgColorful = windowSlice.reduce((s, d) => s + d.colorfulRatio, 0) / windowSlice.length;\n        const avgRarity = windowSlice.reduce((s, d) => s + d.rarityRatio, 0) / windowSlice.length;\n\n        // Score: prefer moderate brightness, high variance, rarity borders present\n        let score = 0;\n\n        // Moderate brightness indicates UI panel area (25-160 range)\n        if (avgBrightness >= 25 && avgBrightness <= 160) {\n            score += 25;\n        }\n\n        // High variance means colorful icons (>200 threshold)\n        if (avgVariance > 200) {\n            score += Math.min(35, avgVariance / 40);\n        }\n\n        // Colorful pixels\n        if (avgColorful > 0.03) {\n            score += avgColorful * 80;\n        }\n\n        // BONUS: Rarity border colors detected (strong signal, >1% threshold)\n        if (avgRarity > 0.01) {\n            score += avgRarity * 150;\n        }\n\n        // Prefer lower on screen (hotbar is at very bottom)\n        const firstStrip = windowSlice[0];\n        const lastStrip = windowSlice[windowSlice.length - 1];\n        if (!firstStrip || !lastStrip) continue;\n\n        const yPosition = firstStrip.y / height;\n        if (yPosition > 0.88) {\n            score += 25;\n        } else if (yPosition > 0.82) {\n            score += 15;\n        }\n\n        if (score > bestScore) {\n            bestScore = score;\n            bestBandStart = firstStrip.y;\n            bestBandEnd = lastStrip.y + stripHeight;\n        }\n    }\n\n    // Fallback if no band found\n    if (bestBandStart === -1) {\n        bestBandStart = Math.floor(height * 0.88);\n        bestBandEnd = height - 5;\n    }\n\n    // Constrain band height - hotbar is typically 1-2 icon rows (~60-120px at 1080p)\n    // Max band height is ~12% of screen height (covers 2 full icon rows with margin)\n    const maxBandHeight = Math.floor(height * 0.12);\n    const minBandHeight = Math.floor(height * 0.06); // ~43px at 720p, ~65px at 1080p\n\n    // If band is too tall, constrain it to reasonable size\n    const currentHeight = bestBandEnd - bestBandStart;\n    if (currentHeight > maxBandHeight) {\n        // Keep the bottom of the band (where hotbar is) and move top down\n        bestBandStart = bestBandEnd - maxBandHeight;\n    }\n\n    if (bestBandEnd - bestBandStart < minBandHeight) {\n        bestBandStart = bestBandEnd - minBandHeight;\n    }\n\n    return {\n        topY: bestBandStart,\n        bottomY: bestBandEnd,\n        height: bestBandEnd - bestBandStart,\n        confidence: Math.min(1, bestScore / 100),\n        debug: { stripData, bestScore },\n    };\n}\n\n// ========================================\n// Pass 2: Rarity Border Detection\n// ========================================\n\n/**\n * Detect item cell edges by finding rarity border colors\n */\nexport function detectRarityBorders(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    bandRegion: BandRegion\n): BorderResult {\n    const { topY, bottomY } = bandRegion;\n    const bandHeight = bottomY - topY;\n\n    // RESTRICT: Only scan center 70% of width (hotbar is centered, avoid UI edges)\n    const scanStartX = Math.floor(width * 0.15);\n    const scanEndX = Math.floor(width * 0.85);\n\n    // Scan multiple horizontal lines within the band\n    const scanLines = [\n        topY + Math.floor(bandHeight * 0.05), // Very top edge of icons\n        topY + Math.floor(bandHeight * 0.15), // Top of icons\n        topY + Math.floor(bandHeight * 0.3), // Upper middle\n        topY + Math.floor(bandHeight * 0.5), // Middle\n        topY + Math.floor(bandHeight * 0.7), // Lower middle\n        topY + Math.floor(bandHeight * 0.85), // Bottom of icons\n        topY + Math.floor(bandHeight * 0.95), // Very bottom edge\n    ];\n\n    // Collect all detected edges across scan lines\n    const allEdges: RawEdge[] = [];\n    const colorCounts: Record<string, number> = {};\n\n    for (const scanY of scanLines) {\n        if (scanY >= ctx.canvas.height) continue;\n\n        const lineData = ctx.getImageData(scanStartX, scanY, scanEndX - scanStartX, 1);\n        const pixels = lineData.data;\n\n        let inBorder = false;\n        let borderStart = -1;\n        let currentRarity: string | null = null;\n\n        for (let localX = 0; localX < scanEndX - scanStartX; localX++) {\n            const x = localX + scanStartX; // Convert to absolute X\n            const idx = localX * 4;\n            const r = pixels[idx] ?? 0;\n            const g = pixels[idx + 1] ?? 0;\n            const b = pixels[idx + 2] ?? 0;\n\n            const rarity = detectRarityAtPixel(r, g, b);\n\n            if (rarity && !inBorder) {\n                // Start of a border\n                inBorder = true;\n                borderStart = x;\n                currentRarity = rarity;\n            } else if (!rarity && inBorder) {\n                // End of a border\n                const borderWidth = x - borderStart;\n\n                // Valid borders are typically 2-8 pixels wide\n                if (borderWidth >= 2 && borderWidth <= 8 && currentRarity) {\n                    allEdges.push({\n                        x: borderStart,\n                        endX: x,\n                        y: scanY,\n                        width: borderWidth,\n                        rarity: currentRarity,\n                        type: 'left',\n                    });\n\n                    colorCounts[currentRarity] = (colorCounts[currentRarity] || 0) + 1;\n                }\n\n                inBorder = false;\n                currentRarity = null;\n            }\n        }\n    }\n\n    // Cluster edges by X position (edges at same X across different scan lines = same icon)\n    let clusteredEdges = clusterEdgesByX(allEdges, 6); // 6px tolerance\n\n    // VERTICAL CONSISTENCY FILTER: True borders appear at multiple Y positions\n    clusteredEdges = filterByVerticalConsistency(clusteredEdges, 2);\n\n    // SPACING CONSISTENCY FILTER: Remove edges that don't fit regular spacing pattern\n    clusteredEdges = filterBySpacingConsistency(clusteredEdges);\n\n    return {\n        edges: clusteredEdges,\n        allEdges,\n        colorCounts,\n        dominantColors: Object.entries(colorCounts)\n            .sort((a, b) => b[1] - a[1])\n            .map(([color]) => color),\n    };\n}\n\n/**\n * Cluster detected edges by X position\n */\nfunction clusterEdgesByX(edges: RawEdge[], tolerance: number): CellEdge[] {\n    if (edges.length === 0) return [];\n\n    // Sort by X position\n    const sorted = [...edges].sort((a, b) => a.x - b.x);\n\n    const firstEdge = sorted[0];\n    if (!firstEdge) return []; // TypeScript guard\n\n    const clusters: RawEdge[][] = [];\n    let currentCluster: RawEdge[] = [firstEdge];\n\n    for (let i = 1; i < sorted.length; i++) {\n        const edge = sorted[i];\n        const lastEdge = currentCluster[currentCluster.length - 1];\n\n        // Skip if edge or lastEdge is undefined (shouldn't happen, but satisfies TypeScript)\n        if (!edge || !lastEdge) continue;\n\n        if (edge.x - lastEdge.x <= tolerance) {\n            // Same cluster\n            currentCluster.push(edge);\n        } else {\n            // New cluster\n            clusters.push(currentCluster);\n            currentCluster = [edge];\n        }\n    }\n\n    // Don't forget the last cluster\n    if (currentCluster.length > 0) {\n        clusters.push(currentCluster);\n    }\n\n    return clusters.map(processCluster);\n}\n\n/**\n * Process a cluster of edges into a single cell edge\n */\nfunction processCluster(edges: RawEdge[]): CellEdge {\n    const avgX = Math.round(edges.reduce((s, e) => s + e.x, 0) / edges.length);\n    const avgWidth = Math.round(edges.reduce((s, e) => s + e.width, 0) / edges.length);\n\n    // Most common rarity in cluster\n    const rarityCounts: Record<string, number> = {};\n    edges.forEach(e => {\n        rarityCounts[e.rarity] = (rarityCounts[e.rarity] || 0) + 1;\n    });\n    const dominantRarity = Object.entries(rarityCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'unknown';\n\n    // Calculate vertical consistency - true borders appear at multiple Y positions\n    const uniqueYs = new Set(edges.map(e => e.y));\n    const verticalConsistency = uniqueYs.size;\n\n    return {\n        x: avgX,\n        borderWidth: avgWidth,\n        rarity: dominantRarity,\n        confidence: edges.length / 7, // More scan lines = higher confidence\n        detections: edges.length,\n        verticalConsistency,\n    };\n}\n\n/**\n * Filter clusters to keep only those with vertical consistency\n * True item borders appear at multiple Y positions, random elements don't\n */\nfunction filterByVerticalConsistency(clusters: CellEdge[], minConsistency: number = 2): CellEdge[] {\n    return clusters.filter(c => c.verticalConsistency >= minConsistency);\n}\n\n/**\n * Filter edges to keep only those that form consistent spacing patterns\n * This removes random noise from gameplay elements (trees, etc.)\n */\nfunction filterBySpacingConsistency(edges: CellEdge[]): CellEdge[] {\n    if (edges.length < 3) {\n        return edges;\n    }\n\n    // Calculate all gaps between consecutive edges\n    const gaps: Array<{ gap: number; fromIdx: number; toIdx: number }> = [];\n    for (let i = 1; i < edges.length; i++) {\n        const current = edges[i];\n        const previous = edges[i - 1];\n        if (!current || !previous) continue;\n\n        const gap = current.x - previous.x;\n        if (gap > 0 && gap < 150) {\n            // Reasonable gap range\n            gaps.push({ gap, fromIdx: i - 1, toIdx: i });\n        }\n    }\n\n    if (gaps.length < 2) {\n        return edges;\n    }\n\n    // Find dominant gap size (icon stride: iconWidth + spacing)\n    // Use histogram approach to find mode\n    const gapCounts = new Map<number, number>();\n    const tolerance = 4; // Allow Â±4px variance\n\n    for (const { gap } of gaps) {\n        const bucket = Math.round(gap / tolerance) * tolerance;\n        gapCounts.set(bucket, (gapCounts.get(bucket) || 0) + 1);\n    }\n\n    // Find the most common gap size\n    let modeGap = 0;\n    let modeCount = 0;\n    for (const [bucket, count] of gapCounts) {\n        if (count > modeCount) {\n            modeCount = count;\n            modeGap = bucket;\n        }\n    }\n\n    // Require at least 3 consistent spacings to be confident\n    if (modeCount < 3) return edges;\n\n    // Keep only edges that participate in consistent-spacing relationships\n    const consistentEdgeIndices = new Set<number>();\n\n    for (const { gap, fromIdx, toIdx } of gaps) {\n        // Check if this gap matches the mode (within tolerance)\n        if (Math.abs(gap - modeGap) <= tolerance) {\n            consistentEdgeIndices.add(fromIdx);\n            consistentEdgeIndices.add(toIdx);\n        }\n    }\n\n    // Also check for multiples of the mode (skipped cells due to empty slots)\n    for (const { gap, fromIdx, toIdx } of gaps) {\n        const multiplier = Math.round(gap / modeGap);\n        if (multiplier >= 2 && multiplier <= 4) {\n            const expectedGap = modeGap * multiplier;\n            if (Math.abs(gap - expectedGap) <= tolerance * multiplier) {\n                consistentEdgeIndices.add(fromIdx);\n                consistentEdgeIndices.add(toIdx);\n            }\n        }\n    }\n\n    // Filter to consistent edges only\n    const filtered = edges.filter((_, idx) => consistentEdgeIndices.has(idx));\n\n    // If we filtered out too many, fall back to original\n    if (filtered.length < 3 && edges.length >= 3) {\n        return edges;\n    }\n\n    return filtered;\n}\n\n// ========================================\n// Pass 3: Icon Size Calculation\n// ========================================\n\n/**\n * Calculate icon dimensions from detected cell edges\n */\nexport function calculateIconMetrics(\n    cellEdges: CellEdge[],\n    width: number,\n    bandRegion: BandRegion,\n    config: AutoGridConfig\n): IconMetrics {\n    if (cellEdges.length < 2) {\n        return getDefaultMetrics(width, bandRegion, config);\n    }\n\n    // Calculate gaps between consecutive edges (this is icon width + spacing)\n    const gaps: number[] = [];\n    for (let i = 1; i < cellEdges.length; i++) {\n        const current = cellEdges[i];\n        const previous = cellEdges[i - 1];\n        if (!current || !previous) continue;\n\n        const gap = current.x - previous.x;\n        // Filter reasonable gaps (20-100px for icon + spacing)\n        if (gap >= 20 && gap <= 100) {\n            gaps.push(gap);\n        }\n    }\n\n    if (gaps.length < 2) {\n        return getDefaultMetrics(width, bandRegion, config);\n    }\n\n    // Find the mode (most common gap size) - this is iconWidth + spacing\n    const gapMode = findMode(gaps);\n\n    // Average border width from edges\n    const avgBorderWidth = Math.round(cellEdges.reduce((s, e) => s + e.borderWidth, 0) / cellEdges.length);\n\n    // Estimate spacing as border width * 1.2 (typical pattern)\n    const estimatedSpacing = Math.max(2, Math.min(10, Math.round(avgBorderWidth * 1.2)));\n\n    // Icon width = total gap - spacing\n    const iconWidth = gapMode - estimatedSpacing;\n\n    // Icon height: typically equals width for square icons\n    const estimatedRowHeight = iconWidth + estimatedSpacing;\n    const possibleRows = Math.floor(bandRegion.height / estimatedRowHeight);\n\n    // Icons are typically square, so height should match width\n    const maxIconHeight = possibleRows >= 1 ? iconWidth : bandRegion.height - 10;\n    const iconHeight = Math.min(iconWidth, Math.max(iconWidth, maxIconHeight));\n\n    // Calculate how many icons fit\n    const totalGridWidth = cellEdges.length * gapMode;\n    const firstCellX = cellEdges[0]?.x ?? 0;\n    const centerOffset = Math.round((width - totalGridWidth) / 2) - firstCellX;\n\n    return {\n        iconWidth: Math.round(iconWidth),\n        iconHeight: Math.round(iconHeight),\n        xSpacing: estimatedSpacing,\n        ySpacing: estimatedSpacing,\n        cellStride: gapMode,\n        borderWidth: avgBorderWidth,\n        confidence: gaps.length / (cellEdges.length - 1),\n        detectedCells: cellEdges.length,\n        firstCellX,\n        centerOffset,\n        debug: { gaps, gapMode },\n    };\n}\n\n/**\n * Find the mode (most common value) with tolerance\n */\nexport function findMode(values: number[], tolerance: number = 2): number {\n    const counts = new Map<number, number>();\n\n    for (const val of values) {\n        // Round to nearest multiple of tolerance\n        const bucket = Math.round(val / tolerance) * tolerance;\n        counts.set(bucket, (counts.get(bucket) || 0) + 1);\n    }\n\n    let maxCount = 0;\n    let mode = values[0] ?? 0;\n\n    for (const [value, count] of counts) {\n        if (count > maxCount) {\n            maxCount = count;\n            mode = value;\n        }\n    }\n\n    return mode;\n}\n\n/**\n * Get default metrics based on resolution\n */\nexport function getDefaultMetrics(_width: number, bandRegion: BandRegion, config: AutoGridConfig): IconMetrics {\n    const height = bandRegion.bottomY;\n    const scale = height / config.baseResolution;\n\n    return {\n        iconWidth: Math.round(config.defaultCalibration.iconWidth * scale),\n        iconHeight: Math.round(config.defaultCalibration.iconHeight * scale),\n        xSpacing: Math.round(config.defaultCalibration.xSpacing * scale),\n        ySpacing: Math.round(config.defaultCalibration.ySpacing * scale),\n        cellStride: Math.round((config.defaultCalibration.iconWidth + config.defaultCalibration.xSpacing) * scale),\n        borderWidth: 3,\n        confidence: 0,\n        detectedCells: 0,\n        firstCellX: null,\n        centerOffset: 0,\n        isDefault: true,\n    };\n}\n\n// ========================================\n// Pass 4: Build Precise Grid\n// ========================================\n\n/**\n * Build the final grid positions from detected metrics\n */\nexport function buildPreciseGrid(\n    metrics: IconMetrics,\n    bandRegion: BandRegion,\n    width: number,\n    height: number,\n    cellEdges: CellEdge[],\n    config: AutoGridConfig\n): GridResult {\n    const positions: GridPosition[] = [];\n    const { iconWidth, iconHeight, xSpacing, ySpacing, cellStride } = metrics;\n\n    // Calculate Y positions for rows\n    const rowHeight = iconHeight + ySpacing;\n    const bandHeight = bandRegion.bottomY - bandRegion.topY;\n\n    // How many rows can fit?\n    const possibleRows = Math.floor(bandHeight / rowHeight);\n    const maxRows = config.maxDetectedRows;\n    const numRows = Math.min(possibleRows, maxRows);\n\n    // Y offset: position first row near bottom of band\n    const bottomMargin = 5;\n    const firstRowY = bandRegion.bottomY - iconHeight - bottomMargin;\n\n    // X positioning: use detected edges if available, otherwise center\n    let startX: number;\n    let iconsPerRow: number;\n\n    if (cellEdges && cellEdges.length >= 2 && metrics.firstCellX !== null) {\n        // Use detected first cell position\n        startX = metrics.firstCellX;\n        iconsPerRow = cellEdges.length;\n    } else {\n        // Calculate centered grid\n        iconsPerRow = Math.floor((width - 100) / cellStride); // 50px margin each side\n        const totalGridWidth = iconsPerRow * cellStride - xSpacing;\n        startX = Math.round((width - totalGridWidth) / 2);\n    }\n\n    // Build grid positions\n    for (let row = 0; row < numRows; row++) {\n        const rowY = firstRowY - row * rowHeight;\n\n        // Don't place rows too high up\n        if (rowY < height * 0.7) break;\n\n        for (let col = 0; col < iconsPerRow; col++) {\n            const cellX = startX + col * cellStride;\n\n            // Skip if outside screen bounds\n            if (cellX < 0 || cellX + iconWidth > width) continue;\n\n            positions.push({\n                x: cellX,\n                y: rowY,\n                width: iconWidth,\n                height: iconHeight,\n                row,\n                col,\n                slotIndex: positions.length,\n            });\n        }\n    }\n\n    // Convert to calibration format (base 720p values)\n    const scale = height / config.baseResolution;\n    const calibration: GridCalibration = {\n        xOffset: Math.round((startX - (width - iconsPerRow * cellStride) / 2) / scale),\n        yOffset: Math.round(100 - (height - firstRowY - iconHeight) / scale),\n        iconWidth: Math.round(iconWidth / scale),\n        iconHeight: Math.round(iconHeight / scale),\n        xSpacing: Math.round(xSpacing / scale),\n        ySpacing: Math.round(ySpacing / scale),\n        iconsPerRow,\n        numRows,\n        totalItems: positions.length,\n    };\n\n    return {\n        positions,\n        calibration,\n        debug: {\n            startX,\n            firstRowY,\n            cellStride,\n            scale,\n        },\n    };\n}\n","// ========================================\n// Grid Validation - Verification and Validation Logic\n// Cell validation, grid validation, preset comparison\n// ========================================\n\nimport type {\n    BandRegion,\n    CellValidation,\n    FieldComparison,\n    GridCalibration,\n    GridPosition,\n    IconMetrics,\n    PresetComparison,\n    ValidatedCell,\n    ValidationResult,\n} from './grid-types.ts';\n\n// ========================================\n// Pass 5: Validate Grid\n// ========================================\n\n/**\n * Validate detected grid positions by checking cell contents\n */\nexport function validateGrid(ctx: CanvasRenderingContext2D, positions: GridPosition[]): ValidationResult {\n    const validCells: ValidatedCell[] = [];\n    const emptyCells: ValidatedCell[] = [];\n    const suspiciousCells: ValidatedCell[] = [];\n\n    for (const cell of positions) {\n        const cellData = ctx.getImageData(cell.x, cell.y, cell.width, cell.height);\n        const validation = validateCell(cellData);\n\n        if (validation.isEmpty) {\n            emptyCells.push({ ...cell, validation });\n        } else if (validation.isSuspicious) {\n            suspiciousCells.push({ ...cell, validation });\n        } else {\n            validCells.push({ ...cell, validation });\n        }\n    }\n\n    // Calculate overall confidence\n    const totalCells = positions.length;\n    const validRatio = validCells.length / totalCells;\n    const emptyRatio = emptyCells.length / totalCells;\n\n    // Good confidence if we have a reasonable number of valid cells\n    // and not too many empty cells in the middle\n    let confidence = validRatio;\n    if (emptyRatio > 0.5) {\n        confidence *= 0.5; // Penalize if mostly empty\n    }\n\n    return {\n        validCells,\n        emptyCells,\n        suspiciousCells,\n        totalCells,\n        confidence,\n        stats: {\n            valid: validCells.length,\n            empty: emptyCells.length,\n            suspicious: suspiciousCells.length,\n        },\n    };\n}\n\n/**\n * Validate a single cell\n */\nfunction validateCell(imageData: ImageData): CellValidation {\n    const pixels = imageData.data;\n\n    let sumR = 0,\n        sumG = 0,\n        sumB = 0;\n    let sumSqR = 0,\n        sumSqG = 0,\n        sumSqB = 0;\n    let colorfulPixels = 0;\n    let count = 0;\n\n    // Sample pixels\n    for (let i = 0; i < pixels.length; i += 16) {\n        const r = pixels[i] ?? 0;\n        const g = pixels[i + 1] ?? 0;\n        const b = pixels[i + 2] ?? 0;\n\n        sumR += r;\n        sumG += g;\n        sumB += b;\n        sumSqR += r * r;\n        sumSqG += g * g;\n        sumSqB += b * b;\n\n        // Check for colorful pixels\n        const saturation = Math.max(r, g, b) - Math.min(r, g, b);\n        if (saturation > 40) colorfulPixels++;\n\n        count++;\n    }\n\n    const meanR = sumR / count;\n    const meanG = sumG / count;\n    const meanB = sumB / count;\n    const meanBrightness = (meanR + meanG + meanB) / 3;\n\n    const varianceR = sumSqR / count - meanR * meanR;\n    const varianceG = sumSqG / count - meanG * meanG;\n    const varianceB = sumSqB / count - meanB * meanB;\n    const totalVariance = varianceR + varianceG + varianceB;\n\n    const colorfulRatio = colorfulPixels / count;\n\n    // Determine cell status\n    // Variance <400 or brightness <30 = likely empty\n    const isEmpty = totalVariance < 400 || meanBrightness < 30;\n    // Variance <600 and colorful ratio <0.1 = suspicious\n    const isSuspicious = totalVariance < 600 && colorfulRatio < 0.1;\n\n    return {\n        isEmpty,\n        isSuspicious,\n        meanBrightness,\n        totalVariance,\n        colorfulRatio,\n    };\n}\n\n// ========================================\n// Overall Confidence Calculation\n// ========================================\n\n/**\n * Calculate overall confidence score\n */\nexport function calculateOverallConfidence(\n    bandRegion: BandRegion,\n    metrics: IconMetrics,\n    validation: ValidationResult\n): number {\n    const bandConf = bandRegion.confidence || 0;\n    const metricsConf = metrics.confidence || 0;\n    const validationConf = validation.confidence || 0;\n\n    // Weighted average\n    const overall = bandConf * 0.2 + metricsConf * 0.4 + validationConf * 0.4;\n\n    return Math.min(1, Math.max(0, overall));\n}\n\n// ========================================\n// Comparison with Presets\n// ========================================\n\n/**\n * Compare auto-detected calibration with a saved preset\n */\nexport function compareWithPreset(\n    autoCalibration: GridCalibration | null,\n    presetCalibration: GridCalibration | null\n): PresetComparison | null {\n    if (!autoCalibration || !presetCalibration) {\n        return null;\n    }\n\n    const fieldNames = [\n        'iconWidth',\n        'iconHeight',\n        'xSpacing',\n        'ySpacing',\n        'xOffset',\n        'yOffset',\n        'iconsPerRow',\n        'numRows',\n    ];\n\n    const fields: Record<string, FieldComparison> = {};\n    let totalDiff = 0;\n    let matchingFields = 0;\n\n    // Define tolerances for each field\n    const tolerances: Record<string, number> = {\n        iconWidth: 3,\n        iconHeight: 3,\n        xSpacing: 2,\n        ySpacing: 2,\n        xOffset: 10,\n        yOffset: 10,\n        iconsPerRow: 2,\n        numRows: 1,\n    };\n\n    for (const field of fieldNames) {\n        const autoVal = (autoCalibration as unknown as Record<string, number>)[field] ?? 0;\n        const presetVal = (presetCalibration as unknown as Record<string, number>)[field] ?? 0;\n        const diff = Math.abs(autoVal - presetVal);\n\n        const tolerance = tolerances[field] ?? 5;\n        const isClose = diff <= tolerance;\n\n        fields[field] = {\n            auto: autoVal,\n            preset: presetVal,\n            diff,\n            isClose,\n        };\n\n        totalDiff += diff;\n        if (isClose) matchingFields++;\n    }\n\n    const matchScore = (matchingFields / fieldNames.length) * 100;\n\n    return {\n        fields,\n        matchScore,\n        totalDiff,\n        recommendation:\n            matchScore >= 70\n                ? 'Auto-detection matches preset well'\n                : 'Auto-detection differs significantly from preset',\n    };\n}\n","// ========================================\n// CV Auto-Grid Detection\n// Dynamic edge detection + multi-pass refinement\n// Self-calibrating grid detection for any resolution\n// Ported from cv-validator/js/auto-grid-detection.js\n// ========================================\n\n// Re-export all types from grid-types for backwards compatibility\nexport type {\n    AutoGridConfig,\n    GridCalibration,\n    StripData,\n    BandRegion,\n    CellEdge,\n    RawEdge,\n    BorderResult,\n    IconMetrics,\n    GridPosition,\n    GridResult,\n    CellValidation,\n    ValidatedCell,\n    ValidationResult,\n    FailureReason,\n    AutoDetectionResult,\n    FieldComparison,\n    PresetComparison,\n    ProgressCallback,\n} from './grid-types.ts';\n\n// Import types for internal use\nimport type {\n    AutoGridConfig,\n    GridCalibration,\n    BandRegion,\n    CellEdge,\n    IconMetrics,\n    GridResult,\n    FailureReason,\n    AutoDetectionResult,\n    ProgressCallback,\n} from './grid-types.ts';\n\n// Import from sub-modules\nimport {\n    detectHotbarBand as _detectHotbarBand,\n    detectRarityBorders as _detectRarityBorders,\n    calculateIconMetrics as _calculateIconMetrics,\n    buildPreciseGrid as _buildPreciseGrid,\n    findMode as _findMode,\n    getDefaultMetrics as _getDefaultMetrics,\n} from './grid-analysis.ts';\n\nimport {\n    validateGrid as _validateGrid,\n    calculateOverallConfidence as _calculateOverallConfidence,\n    compareWithPreset as _compareWithPreset,\n} from './grid-validation.ts';\n\nimport { drawDetectionOverlay as _drawDetectionOverlay } from './grid-utils.ts';\n\n// ========================================\n// Default Configuration\n// ========================================\n\nconst DEFAULT_CONFIG: AutoGridConfig = {\n    baseResolution: 720,\n    maxDetectedRows: 2,\n    defaultCalibration: {\n        xOffset: 0,\n        yOffset: 0,\n        iconWidth: 40,\n        iconHeight: 40,\n        xSpacing: 4,\n        ySpacing: 4,\n        iconsPerRow: 20,\n        numRows: 3,\n        totalItems: 60,\n    },\n};\n\n// Module-level config that can be overridden\nlet config: AutoGridConfig = { ...DEFAULT_CONFIG };\n\n/**\n * Set custom configuration\n */\nexport function setConfig(customConfig: Partial<AutoGridConfig>): void {\n    config = { ...config, ...customConfig };\n}\n\n/**\n * Get current configuration\n */\nexport function getConfig(): AutoGridConfig {\n    return { ...config };\n}\n\n// ========================================\n// Re-exported Functions (with config wrappers where needed)\n// ========================================\n\n/**\n * Detect the hotbar band region at the bottom of the screen\n */\nexport const detectHotbarBand = _detectHotbarBand;\n\n/**\n * Detect item cell edges by finding rarity border colors\n */\nexport const detectRarityBorders = _detectRarityBorders;\n\n/**\n * Calculate icon dimensions from detected cell edges\n * Uses module-level config by default\n */\nexport function calculateIconMetrics(\n    cellEdges: CellEdge[],\n    width: number,\n    bandRegion: BandRegion\n): IconMetrics {\n    return _calculateIconMetrics(cellEdges, width, bandRegion, config);\n}\n\n/**\n * Build the final grid positions from detected metrics\n * Uses module-level config by default\n */\nexport function buildPreciseGrid(\n    metrics: IconMetrics,\n    bandRegion: BandRegion,\n    width: number,\n    height: number,\n    cellEdges: CellEdge[]\n): GridResult {\n    return _buildPreciseGrid(metrics, bandRegion, width, height, cellEdges, config);\n}\n\n/**\n * Get default metrics based on resolution\n * Uses module-level config by default\n */\nexport function getDefaultMetrics(width: number, bandRegion: BandRegion): IconMetrics {\n    return _getDefaultMetrics(width, bandRegion, config);\n}\n\n/**\n * Find the mode (most common value) with tolerance\n */\nexport const findMode = _findMode;\n\n/**\n * Validate detected grid positions by checking cell contents\n */\nexport const validateGrid = _validateGrid;\n\n/**\n * Calculate overall confidence score\n */\nexport const calculateOverallConfidence = _calculateOverallConfidence;\n\n/**\n * Compare auto-detected calibration with a saved preset\n */\nexport const compareWithPreset = _compareWithPreset;\n\n/**\n * Draw detection overlay on canvas for debugging\n */\nexport const drawDetectionOverlay = _drawDetectionOverlay;\n\n// ========================================\n// Main Auto-Detection Function\n// ========================================\n\n/**\n * Run full auto-detection pipeline\n */\nexport async function autoDetectGrid(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    options: { progressCallback?: ProgressCallback } = {}\n): Promise<AutoDetectionResult> {\n    const startTime = Date.now();\n    const { progressCallback } = options;\n\n    try {\n        // Pass 1: Detect hotbar band\n        if (progressCallback) progressCallback(10, 'Detecting hotbar region...');\n        const bandRegion = detectHotbarBand(ctx, width, height);\n\n        // Pass 2: Detect rarity borders\n        if (progressCallback) progressCallback(30, 'Finding item borders...');\n        const borderResult = detectRarityBorders(ctx, width, bandRegion);\n\n        // Pass 3: Calculate icon metrics\n        if (progressCallback) progressCallback(50, 'Calculating icon sizes...');\n        const metrics = calculateIconMetrics(borderResult.edges, width, bandRegion);\n\n        // Pass 4: Build grid\n        if (progressCallback) progressCallback(70, 'Building grid...');\n        const gridResult = buildPreciseGrid(metrics, bandRegion, width, height, borderResult.edges);\n\n        // Pass 5: Validate\n        if (progressCallback) progressCallback(90, 'Validating cells...');\n        const validation = validateGrid(ctx, gridResult.positions);\n\n        // Pass 6: Empty screen detection\n        // Icons smaller than 22px absolute are likely false positives from UI elements\n        const minAbsoluteIconSize = 22;\n        const iconsTooSmall = metrics.iconWidth < minAbsoluteIconSize || metrics.iconHeight < minAbsoluteIconSize;\n\n        const isLikelyEmpty = bandRegion.confidence < 0.4 && borderResult.edges.length < 3 && metrics.isDefault;\n\n        const hasInconsistentDetection =\n            borderResult.edges.length >= 2 && metrics.confidence < 0.3 && validation.validCells.length < 3;\n\n        // Collect failure reasons for UI display\n        const failureReasons: FailureReason[] = [];\n        if (iconsTooSmall) {\n            failureReasons.push('icons_too_small');\n        }\n        if (isLikelyEmpty) {\n            failureReasons.push('likely_empty_screen');\n        }\n        if (hasInconsistentDetection) {\n            failureReasons.push('inconsistent_detection');\n        }\n        if (borderResult.edges.length === 0) {\n            failureReasons.push('no_vertical_clusters');\n        }\n\n        if (isLikelyEmpty || hasInconsistentDetection || iconsTooSmall) {\n            validation.validCells = [];\n            validation.confidence = 0;\n            validation.failureReasons = failureReasons;\n        }\n\n        const elapsed = Date.now() - startTime;\n\n        if (progressCallback) progressCallback(100, 'Done!');\n\n        return {\n            success: true,\n            bandRegion,\n            borders: borderResult,\n            metrics,\n            grid: gridResult,\n            validation,\n            calibration: gridResult.calibration,\n            elapsed,\n            confidence: calculateOverallConfidence(bandRegion, metrics, validation),\n            reasons: failureReasons.length > 0 ? failureReasons : null,\n        };\n    } catch (error) {\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : String(error),\n            reasons: ['exception_thrown'],\n            calibration: null,\n        };\n    }\n}\n\n// ========================================\n// Default Export\n// ========================================\n\nexport default {\n    autoDetectGrid,\n    detectHotbarBand,\n    detectRarityBorders,\n    calculateIconMetrics,\n    buildPreciseGrid,\n    validateGrid,\n    compareWithPreset,\n    drawDetectionOverlay,\n    setConfig,\n    getConfig,\n};\n","// ========================================\n// MegaBonk Build Planner Screenshot Import\n// ========================================\n// Handles screenshot upload and CV detection to populate Build Planner\n// ========================================\n\nimport type { Item, Tome, AllGameData, Character, Weapon } from '../types/index.ts';\nimport { ToastManager } from './toast.ts';\nimport { logger } from './logger.ts';\nimport {\n    detectItemsWithCV,\n    initCV,\n    loadItemTemplates,\n    combineDetections,\n    aggregateDuplicates,\n    isFullyLoaded as isCVFullyLoaded,\n    autoDetectGrid,\n    getPresetForResolution,\n    loadGridPresets,\n} from './cv/index.ts';\nimport { autoDetectFromImage, initOCR, type DetectionResult } from './ocr/index.ts';\nimport { loadBuildFromData } from './build-planner.ts';\nimport { escapeHtml } from './utils.ts';\n\n// ========================================\n// Types\n// ========================================\n\ninterface DetectedBuild {\n    character: Character | null;\n    weapon: Weapon | null;\n    items: { item: Item; count: number; confidence: number }[];\n    tomes: { tome: Tome; confidence: number }[];\n}\n\ninterface ScanProgress {\n    progress: number;\n    status: string;\n}\n\ntype ProgressCallback = (progress: ScanProgress) => void;\n\n// ========================================\n// State\n// ========================================\n\n// Note: Game data stored by initCV and initOCR, no need to duplicate here\nlet isInitialized = false;\nlet templatesLoaded = false;\nlet presetsLoaded = false;\n\n// Modal state\nlet previewModal: HTMLElement | null = null;\nlet currentDetectedBuild: DetectedBuild | null = null;\n\n// ========================================\n// Initialization\n// ========================================\n\n/**\n * Initialize the build planner scan module\n */\nexport async function initBuildPlannerScan(gameData: AllGameData): Promise<void> {\n    if (isInitialized) return;\n\n    // Initialize CV and OCR modules\n    initCV(gameData);\n    initOCR(gameData);\n\n    // Load templates and presets in parallel\n    const loadPromises: Promise<void>[] = [];\n\n    loadPromises.push(\n        loadItemTemplates()\n            .then(() => {\n                templatesLoaded = true;\n                logger.info({\n                    operation: 'build_planner_scan.templates_loaded',\n                    data: { success: true },\n                });\n            })\n            .catch(error => {\n                logger.warn({\n                    operation: 'build_planner_scan.templates_load_failed',\n                    error: { name: (error as Error).name, message: (error as Error).message },\n                });\n            })\n    );\n\n    loadPromises.push(\n        loadGridPresets()\n            .then(() => {\n                presetsLoaded = true;\n                logger.info({\n                    operation: 'build_planner_scan.presets_loaded',\n                    data: { success: true },\n                });\n            })\n            .catch(error => {\n                logger.warn({\n                    operation: 'build_planner_scan.presets_load_failed',\n                    error: { name: (error as Error).name, message: (error as Error).message },\n                });\n            })\n    );\n\n    // Wait for both to complete (don't fail if one fails)\n    await Promise.allSettled(loadPromises);\n\n    // Setup UI elements\n    setupUI();\n    setupEventListeners();\n\n    isInitialized = true;\n\n    logger.info({\n        operation: 'build_planner_scan.init',\n        data: {\n            templatesLoaded,\n            presetsLoaded,\n            itemsCount: gameData.items?.items.length || 0,\n        },\n    });\n}\n\n/**\n * Setup UI elements for screenshot import\n */\nfunction setupUI(): void {\n    // Add import button to build actions\n    const buildActions = document.querySelector('.build-actions');\n    if (buildActions && !document.getElementById('import-screenshot-btn')) {\n        const importBtn = document.createElement('button');\n        importBtn.id = 'import-screenshot-btn';\n        importBtn.className = 'btn-primary';\n        importBtn.innerHTML = 'ðŸ“· Import from Screenshot';\n        importBtn.title = 'Upload a screenshot to auto-detect items';\n\n        // Insert at the beginning of the actions\n        buildActions.insertBefore(importBtn, buildActions.firstChild);\n\n        // Create hidden file input\n        const fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.id = 'build-planner-file-input';\n        fileInput.accept = 'image/*';\n        fileInput.style.display = 'none';\n        buildActions.appendChild(fileInput);\n    }\n\n    // Create preview modal if it doesn't exist\n    if (!document.getElementById('build-planner-scan-modal')) {\n        const modal = document.createElement('div');\n        modal.id = 'build-planner-scan-modal';\n        modal.className = 'modal build-scan-modal';\n        modal.innerHTML = `\n            <div class=\"modal-content modal-wide\">\n                <button class=\"close\" id=\"close-scan-modal\" aria-label=\"Close modal\">&times;</button>\n                <h2>ðŸ“· Import Build from Screenshot</h2>\n                <div id=\"build-scan-content\">\n                    <!-- Content loaded dynamically -->\n                </div>\n            </div>\n        `;\n        document.body.appendChild(modal);\n        previewModal = modal;\n    }\n}\n\n/**\n * Setup event listeners\n */\nfunction setupEventListeners(): void {\n    // Import button click\n    const importBtn = document.getElementById('import-screenshot-btn');\n    importBtn?.addEventListener('click', handleImportClick);\n\n    // File input change\n    const fileInput = document.getElementById('build-planner-file-input') as HTMLInputElement;\n    fileInput?.addEventListener('change', handleFileSelect);\n\n    // Modal close button\n    const closeBtn = document.getElementById('close-scan-modal');\n    closeBtn?.addEventListener('click', closePreviewModal);\n\n    // Close modal on outside click\n    previewModal?.addEventListener('click', e => {\n        if (e.target === previewModal) {\n            closePreviewModal();\n        }\n    });\n\n    // Close on escape key\n    document.addEventListener('keydown', e => {\n        if (e.key === 'Escape' && previewModal?.style.display === 'flex') {\n            closePreviewModal();\n        }\n    });\n}\n\n// ========================================\n// Event Handlers\n// ========================================\n\n/**\n * Handle import button click\n */\nfunction handleImportClick(): void {\n    const fileInput = document.getElementById('build-planner-file-input') as HTMLInputElement;\n    fileInput?.click();\n}\n\n/**\n * Handle file selection\n */\nasync function handleFileSelect(e: Event): Promise<void> {\n    const input = e.target as HTMLInputElement;\n    const file = input.files?.[0];\n\n    if (!file) return;\n\n    // Validate file type\n    if (!file.type.startsWith('image/')) {\n        ToastManager.error('Please select an image file');\n        return;\n    }\n\n    // Validate file size (max 10MB)\n    if (file.size > 10 * 1024 * 1024) {\n        ToastManager.error('Image size must be less than 10MB');\n        return;\n    }\n\n    try {\n        // Read file as data URL\n        const imageData = await readFileAsDataURL(file);\n\n        // Show modal with processing state\n        showProcessingModal(imageData);\n\n        // Run detection\n        const detectedBuild = await detectBuildFromImage(imageData, progress => {\n            updateProcessingProgress(progress);\n        });\n\n        // Show preview\n        showPreviewModal(imageData, detectedBuild);\n\n        logger.info({\n            operation: 'build_planner_scan.file_processed',\n            data: {\n                fileName: file.name,\n                fileSize: file.size,\n                itemsDetected: detectedBuild.items.length,\n                tomesDetected: detectedBuild.tomes.length,\n            },\n        });\n    } catch (error) {\n        logger.error({\n            operation: 'build_planner_scan.process_error',\n            error: {\n                name: (error as Error).name,\n                message: (error as Error).message,\n            },\n        });\n        ToastManager.error(`Failed to process screenshot: ${(error as Error).message}`);\n        closePreviewModal();\n    }\n\n    // Reset file input for next upload\n    input.value = '';\n}\n\n// ========================================\n// Image Processing\n// ========================================\n\n/**\n * Read file as data URL\n */\nfunction readFileAsDataURL(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = event => {\n            const result = event.target?.result;\n            if (typeof result === 'string') {\n                resolve(result);\n            } else {\n                reject(new Error('Failed to read image'));\n            }\n        };\n        reader.onerror = () => reject(new Error('Failed to read file'));\n        reader.readAsDataURL(file);\n    });\n}\n\n/**\n * Detect build from image using CV and OCR\n */\nasync function detectBuildFromImage(imageData: string, onProgress?: ProgressCallback): Promise<DetectedBuild> {\n    const report = (progress: number, status: string) => {\n        onProgress?.({ progress, status });\n    };\n\n    report(5, 'Loading image...');\n\n    // Get image dimensions for preset lookup\n    const img = new Image();\n    await new Promise<void>((resolve, reject) => {\n        img.onload = () => resolve();\n        img.onerror = () => reject(new Error('Failed to load image'));\n        img.src = imageData;\n    });\n\n    const width = img.naturalWidth;\n    const height = img.naturalHeight;\n\n    report(10, 'Detecting grid layout...');\n\n    // Try to get preset for this resolution\n    let gridConfig = getPresetForResolution(width, height);\n\n    // If no preset, try auto-detection\n    if (!gridConfig && presetsLoaded) {\n        try {\n            report(15, 'Auto-detecting grid...');\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            const ctx = canvas.getContext('2d');\n            if (ctx) {\n                ctx.drawImage(img, 0, 0);\n                const autoResult = await autoDetectGrid(ctx, width, height);\n                if (autoResult.success && autoResult.calibration) {\n                    logger.info({\n                        operation: 'build_planner_scan.auto_grid_success',\n                        data: { calibration: autoResult.calibration },\n                    });\n                }\n            }\n        } catch (error) {\n            logger.warn({\n                operation: 'build_planner_scan.auto_grid_failed',\n                error: { name: (error as Error).name, message: (error as Error).message },\n            });\n        }\n    }\n\n    // Run OCR detection\n    report(20, 'Running text recognition...');\n    let ocrResults: {\n        items: DetectionResult[];\n        tomes: DetectionResult[];\n        character: DetectionResult | null;\n        weapon: DetectionResult | null;\n    } = { items: [], tomes: [], character: null, weapon: null };\n\n    try {\n        ocrResults = await autoDetectFromImage(imageData, (progress, status) => {\n            report(20 + progress * 0.3, status);\n        });\n    } catch (error) {\n        logger.warn({\n            operation: 'build_planner_scan.ocr_failed',\n            error: { name: (error as Error).name, message: (error as Error).message },\n        });\n    }\n\n    // Run CV detection\n    report(50, 'Running icon recognition...');\n    let cvResults: Array<{\n        entity: Item | Tome | Character | Weapon;\n        confidence: number;\n        type: string;\n        method: 'template_match' | 'icon_similarity' | 'hybrid';\n    }> = [];\n\n    if (templatesLoaded || isCVFullyLoaded()) {\n        try {\n            const rawCvResults = await detectItemsWithCV(imageData, (progress, status) => {\n                report(50 + progress * 0.4, status);\n            });\n            // Add method property to match CVDetectionResult type\n            cvResults = rawCvResults.map(r => ({\n                ...r,\n                method: 'template_match' as const,\n            }));\n        } catch (error) {\n            logger.warn({\n                operation: 'build_planner_scan.cv_failed',\n                error: { name: (error as Error).name, message: (error as Error).message },\n            });\n        }\n    }\n\n    // Combine results\n    report(90, 'Combining detections...');\n\n    // Convert CV results to OCR format for combining\n    const cvAsOCR: DetectionResult[] = cvResults.map(cv => ({\n        type: cv.type as 'item' | 'tome' | 'character' | 'weapon',\n        entity: cv.entity,\n        confidence: cv.confidence,\n        rawText: `cv_detected_${cv.entity.name}`,\n    }));\n\n    // Combine and aggregate - pass CV results as CVDetectionResult[]\n    const cvItemResults = cvResults\n        .filter(r => r.type === 'item')\n        .map(r => ({ ...r, type: r.type as 'item' | 'tome' | 'character' | 'weapon' }));\n    const cvTomeResults = cvResults\n        .filter(r => r.type === 'tome')\n        .map(r => ({ ...r, type: r.type as 'item' | 'tome' | 'character' | 'weapon' }));\n\n    const combinedItems = combineDetections(\n        [...ocrResults.items, ...cvAsOCR.filter(r => r.type === 'item')],\n        cvItemResults\n    );\n    const combinedTomes = combineDetections(\n        [...ocrResults.tomes, ...cvAsOCR.filter(r => r.type === 'tome')],\n        cvTomeResults\n    );\n\n    const aggregatedItems = aggregateDuplicates(combinedItems);\n    const aggregatedTomes = aggregateDuplicates(combinedTomes);\n\n    // Build result\n    const detectedBuild: DetectedBuild = {\n        character: ocrResults.character\n            ? (ocrResults.character.entity as Character)\n            : (cvResults.find(r => r.type === 'character')?.entity as Character) || null,\n        weapon: ocrResults.weapon\n            ? (ocrResults.weapon.entity as Weapon)\n            : (cvResults.find(r => r.type === 'weapon')?.entity as Weapon) || null,\n        items: aggregatedItems.map(r => ({\n            item: r.entity as Item,\n            count: r.count || 1,\n            confidence: r.confidence,\n        })),\n        tomes: aggregatedTomes.map(r => ({\n            tome: r.entity as Tome,\n            confidence: r.confidence,\n        })),\n    };\n\n    report(100, 'Detection complete!');\n\n    return detectedBuild;\n}\n\n// ========================================\n// Modal UI\n// ========================================\n\n/**\n * Show processing modal\n */\nfunction showProcessingModal(imageData: string): void {\n    if (!previewModal) return;\n\n    const content = document.getElementById('build-scan-content');\n    if (content) {\n        content.innerHTML = `\n            <div class=\"build-scan-processing\">\n                <div class=\"build-scan-image-preview\">\n                    <img src=\"${imageData}\" alt=\"Processing screenshot\" />\n                </div>\n                <div class=\"build-scan-progress\">\n                    <div class=\"build-scan-progress-bar\">\n                        <div class=\"build-scan-progress-fill\" style=\"width: 0%\"></div>\n                    </div>\n                    <p class=\"build-scan-progress-text\">Initializing...</p>\n                </div>\n            </div>\n        `;\n    }\n\n    previewModal.style.display = 'flex';\n}\n\n/**\n * Update processing progress\n */\nfunction updateProcessingProgress(progress: ScanProgress): void {\n    const fill = document.querySelector('.build-scan-progress-fill') as HTMLElement;\n    const text = document.querySelector('.build-scan-progress-text');\n\n    if (fill) {\n        fill.style.width = `${progress.progress}%`;\n    }\n    if (text) {\n        text.textContent = progress.status;\n    }\n}\n\n/**\n * Show preview modal with detection results\n */\nfunction showPreviewModal(imageData: string, detectedBuild: DetectedBuild): void {\n    if (!previewModal) return;\n\n    currentDetectedBuild = detectedBuild;\n\n    const totalItems = detectedBuild.items.reduce((sum, i) => sum + i.count, 0);\n    const avgConfidence =\n        detectedBuild.items.length > 0\n            ? detectedBuild.items.reduce((sum, i) => sum + i.confidence, 0) / detectedBuild.items.length\n            : 0;\n\n    const content = document.getElementById('build-scan-content');\n    if (content) {\n        content.innerHTML = `\n            <div class=\"build-scan-preview\">\n                <div class=\"build-scan-image-preview\">\n                    <img src=\"${imageData}\" alt=\"Uploaded screenshot\" />\n                </div>\n\n                <div class=\"build-scan-results\">\n                    <h3>Detected Items</h3>\n\n                    ${\n                        detectedBuild.items.length === 0 && detectedBuild.tomes.length === 0\n                            ? '<p class=\"build-scan-empty\">No items detected. Try a clearer screenshot of the pause menu.</p>'\n                            : `\n                            <div class=\"build-scan-stats\">\n                                <span>${totalItems} items</span>\n                                <span>${detectedBuild.tomes.length} tomes</span>\n                                <span>Avg confidence: ${Math.round(avgConfidence * 100)}%</span>\n                            </div>\n\n                            ${\n                                detectedBuild.character\n                                    ? `\n                                <div class=\"build-scan-section\">\n                                    <h4>Character</h4>\n                                    <div class=\"build-scan-entity\">${escapeHtml(detectedBuild.character.name)}</div>\n                                </div>\n                            `\n                                    : ''\n                            }\n\n                            ${\n                                detectedBuild.weapon\n                                    ? `\n                                <div class=\"build-scan-section\">\n                                    <h4>Weapon</h4>\n                                    <div class=\"build-scan-entity\">${escapeHtml(detectedBuild.weapon.name)}</div>\n                                </div>\n                            `\n                                    : ''\n                            }\n\n                            ${\n                                detectedBuild.items.length > 0\n                                    ? `\n                                <div class=\"build-scan-section\">\n                                    <h4>Items</h4>\n                                    <div class=\"build-scan-items-list\">\n                                        ${detectedBuild.items\n                                            .map(\n                                                ({ item, count, confidence }) => `\n                                            <div class=\"build-scan-item ${getConfidenceClass(confidence)}\">\n                                                <span class=\"item-name\">${escapeHtml(item.name)}${count > 1 ? ` x${count}` : ''}</span>\n                                                <span class=\"item-confidence\">${Math.round(confidence * 100)}%</span>\n                                            </div>\n                                        `\n                                            )\n                                            .join('')}\n                                    </div>\n                                </div>\n                            `\n                                    : ''\n                            }\n\n                            ${\n                                detectedBuild.tomes.length > 0\n                                    ? `\n                                <div class=\"build-scan-section\">\n                                    <h4>Tomes</h4>\n                                    <div class=\"build-scan-items-list\">\n                                        ${detectedBuild.tomes\n                                            .map(\n                                                ({ tome, confidence }) => `\n                                            <div class=\"build-scan-item ${getConfidenceClass(confidence)}\">\n                                                <span class=\"item-name\">${escapeHtml(tome.name)}</span>\n                                                <span class=\"item-confidence\">${Math.round(confidence * 100)}%</span>\n                                            </div>\n                                        `\n                                            )\n                                            .join('')}\n                                    </div>\n                                </div>\n                            `\n                                    : ''\n                            }\n                        `\n                    }\n                </div>\n\n                <div class=\"build-scan-actions\">\n                    ${\n                        detectedBuild.items.length > 0 || detectedBuild.tomes.length > 0\n                            ? `\n                        <button id=\"apply-detected-build\" class=\"btn-primary\">\n                            âœ… Apply to Build Planner\n                        </button>\n                    `\n                            : ''\n                    }\n                    <button id=\"cancel-detected-build\" class=\"btn-secondary\">\n                        Cancel\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Setup action buttons\n        const applyBtn = document.getElementById('apply-detected-build');\n        applyBtn?.addEventListener('click', applyDetectedBuild);\n\n        const cancelBtn = document.getElementById('cancel-detected-build');\n        cancelBtn?.addEventListener('click', closePreviewModal);\n    }\n}\n\n/**\n * Get CSS class based on confidence level\n */\nfunction getConfidenceClass(confidence: number): string {\n    if (confidence >= 0.8) return 'confidence-high';\n    if (confidence >= 0.5) return 'confidence-medium';\n    return 'confidence-low';\n}\n\n/**\n * Close preview modal\n */\nfunction closePreviewModal(): void {\n    if (previewModal) {\n        previewModal.style.display = 'none';\n    }\n    currentDetectedBuild = null;\n}\n\n/**\n * Apply detected build to the Build Planner\n */\nfunction applyDetectedBuild(): void {\n    if (!currentDetectedBuild) {\n        ToastManager.error('No detected build to apply');\n        return;\n    }\n\n    // Convert to BuildData format\n    const buildData = {\n        character: currentDetectedBuild.character?.id,\n        weapon: currentDetectedBuild.weapon?.id,\n        // For items, we take unique items (build planner doesn't support stacks)\n        items: [...new Set(currentDetectedBuild.items.map(i => i.item.id))],\n        tomes: currentDetectedBuild.tomes.map(t => t.tome.id),\n        name: 'Imported Build',\n        notes: `Imported from screenshot on ${new Date().toLocaleString()}`,\n    };\n\n    // Load into build planner\n    loadBuildFromData(buildData);\n\n    // Close modal\n    closePreviewModal();\n\n    // Show success message\n    const itemCount = buildData.items.length;\n    const tomeCount = buildData.tomes.length;\n    ToastManager.success(`Applied ${itemCount} items and ${tomeCount} tomes to Build Planner!`);\n\n    logger.info({\n        operation: 'build_planner_scan.build_applied',\n        data: {\n            characterId: buildData.character,\n            weaponId: buildData.weapon,\n            itemsCount: itemCount,\n            tomesCount: tomeCount,\n        },\n    });\n}\n\n// ========================================\n// Exports\n// ========================================\n\nexport { closePreviewModal, applyDetectedBuild };\n"],"names":["processCluster","edges","avgX","Math","round","reduce","s","e","x","length","avgWidth","width","rarityCounts","forEach","rarity","dominantRarity","Object","entries","sort","a","b","verticalConsistency","Set","map","y","size","borderWidth","confidence","detections","calculateIconMetrics","cellEdges","bandRegion","config","getDefaultMetrics","gaps","i","current","previous","gap","push","gapMode","values","tolerance","counts","Map","val","bucket","set","get","maxCount","mode","value","count","findMode","avgBorderWidth","estimatedSpacing","max","min","iconWidth","estimatedRowHeight","maxIconHeight","floor","height","iconHeight","totalGridWidth","firstCellX","centerOffset","xSpacing","ySpacing","cellStride","detectedCells","debug","_width","scale","bottomY","baseResolution","defaultCalibration","isDefault","validateCell","imageData","pixels","data","sumR","sumG","sumB","sumSqR","sumSqG","sumSqB","colorfulPixels","r","g","meanR","meanG","meanB","meanBrightness","totalVariance","colorfulRatio","isEmpty","isSuspicious","maxDetectedRows","xOffset","yOffset","iconsPerRow","numRows","totalItems","detectHotbarBand","ctx","scanStartY","sampleStartX","sampleWidth","stripData","getImageData","totalBrightness","rarityBorderPixels","brightness","mean","pow","detectRarityAtPixel","avgBrightness","avgVariance","rarityRatio","bestBandStart","bestBandEnd","bestScore","windowSlice","slice","d","avgColorful","avgRarity","score","firstStrip","lastStrip","yPosition","maxBandHeight","minBandHeight","topY","detectRarityBorders","bandHeight","scanStartX","scanEndX","scanLines","allEdges","colorCounts","scanY","canvas","inBorder","borderStart","currentRarity","localX","idx","endX","type","clusteredEdges","sorted","firstEdge","clusters","currentCluster","edge","lastEdge","clusterEdgesByX","minConsistency","filter","c","filterByVerticalConsistency","fromIdx","toIdx","gapCounts","modeGap","modeCount","consistentEdgeIndices","abs","add","multiplier","expectedGap","filtered","_","has","filterBySpacingConsistency","dominantColors","color","buildPreciseGrid","metrics","positions","rowHeight","possibleRows","maxRows","firstRowY","startX","row","rowY","col","cellX","slotIndex","calibration","_buildPreciseGrid","validateGrid","validCells","emptyCells","suspiciousCells","cell","validation","totalCells","stats","valid","empty","suspicious","calculateOverallConfidence","overall","async","autoDetectGrid","options","startTime","Date","now","progressCallback","borderResult","_calculateIconMetrics","gridResult","minAbsoluteIconSize","iconsTooSmall","isLikelyEmpty","hasInconsistentDetection","failureReasons","elapsed","success","borders","grid","reasons","error","Error","message","String","isInitialized","templatesLoaded","presetsLoaded","previewModal","currentDetectedBuild","initBuildPlannerScan","gameData","initCV","initOCR","loadPromises","loadItemTemplates","then","logger","info","operation","catch","warn","name","loadGridPresets","Promise","allSettled","buildActions","document","querySelector","getElementById","importBtn","createElement","id","className","innerHTML","title","insertBefore","firstChild","fileInput","accept","style","display","appendChild","modal","body","setupUI","addEventListener","handleImportClick","handleFileSelect","closeBtn","closePreviewModal","target","key","setupEventListeners","itemsCount","items","click","input","file","files","startsWith","ToastManager","resolve","reject","reader","FileReader","onload","event","result","onerror","readAsDataURL","readFileAsDataURL","content","showProcessingModal","detectedBuild","onProgress","report","progress","status","img","Image","src","naturalWidth","naturalHeight","getPresetForResolution","getContext","drawImage","autoResult","ocrResults","tomes","character","weapon","autoDetectFromImage","cvResults","isCVFullyLoaded","detectItemsWithCV","method","cvAsOCR","cv","entity","rawText","cvItemResults","cvTomeResults","combinedItems","combineDetections","combinedTomes","aggregatedItems","aggregateDuplicates","aggregatedTomes","find","item","tome","detectBuildFromImage","fill","text","textContent","updateProcessingProgress","sum","avgConfidence","escapeHtml","getConfidenceClass","join","applyBtn","applyDetectedBuild","cancelBtn","showPreviewModal","fileName","fileSize","itemsDetected","tomesDetected","buildData","t","notes","toLocaleString","loadBuildFromData","itemCount","tomeCount","characterId","weaponId","tomesCount"],"mappings":"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"}