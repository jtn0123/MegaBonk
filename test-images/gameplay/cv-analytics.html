<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CV Analytics Dashboard - MegaBonk</title>
    <link rel="stylesheet" href="cv-validator/styles/base.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            margin-bottom: 8px;
        }

        .header-info {
            color: var(--text-secondary);
            margin-bottom: 24px;
        }

        .page-nav {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 16px;
            padding: 8px;
            background: var(--bg-panel);
            border-radius: 6px;
        }

        .page-nav a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 13px;
            padding: 4px 10px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .page-nav a:hover {
            color: var(--text-primary);
            background: var(--bg-card);
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
        }

        .stat-card h3 {
            margin: 0 0 16px 0;
            color: var(--text-secondary);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 36px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stat-value.good { color: var(--success); }
        .stat-value.warning { color: var(--warning); }
        .stat-value.bad { color: var(--error); }

        .stat-detail {
            font-size: 13px;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .section {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 24px;
        }

        .section h2 {
            margin: 0 0 16px 0;
            font-size: 18px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 12px;
        }

        .table-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        th, td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        th {
            background: var(--bg-secondary);
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
        }

        th:hover {
            background: var(--bg-primary);
        }

        tr:hover {
            background: var(--bg-secondary);
        }

        .coverage-bar {
            width: 100px;
            height: 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            overflow: hidden;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }

        .coverage-fill {
            height: 100%;
            background: var(--success);
        }

        .coverage-fill.low { background: var(--error); }
        .coverage-fill.medium { background: var(--warning); }
        .coverage-fill.high { background: var(--success); }

        .confusion-matrix {
            display: grid;
            grid-template-columns: auto repeat(var(--cols, 5), 1fr);
            gap: 2px;
            font-size: 11px;
            max-width: 100%;
            overflow-x: auto;
        }

        .matrix-cell {
            padding: 8px;
            text-align: center;
            background: var(--bg-secondary);
            border-radius: 2px;
        }

        .matrix-cell.header {
            background: var(--bg-primary);
            font-weight: 600;
            color: var(--text-secondary);
        }

        .matrix-cell.high {
            background: rgba(239, 68, 68, 0.3);
        }

        .matrix-cell.medium {
            background: rgba(251, 191, 36, 0.3);
        }

        .chart-container {
            height: 200px;
            display: flex;
            align-items: flex-end;
            gap: 4px;
            padding: 20px 0;
        }

        .chart-bar {
            flex: 1;
            background: var(--accent);
            border-radius: 4px 4px 0 0;
            min-width: 20px;
            position: relative;
        }

        .chart-bar:hover {
            background: var(--success);
        }

        .chart-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--error);
            padding: 16px;
            border-radius: 8px;
            color: var(--error);
        }

        .actions {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 16px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 13px;
        }

        button:hover {
            border-color: var(--accent);
        }

        button.primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        .resolution-breakdown {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .resolution-tag {
            background: var(--bg-secondary);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
        }

        .resolution-tag .count {
            color: var(--accent);
            font-weight: 600;
        }

        /* Confusion heatmap styles */
        .confusion-heatmap-container {
            overflow-x: auto;
            padding: 10px 0;
        }

        .confusion-heatmap {
            display: grid;
            gap: 2px;
            font-size: 10px;
            min-width: fit-content;
        }

        .heatmap-row {
            display: contents;
        }

        .heatmap-header {
            background: var(--bg-primary);
            padding: 6px 8px;
            font-weight: 600;
            color: var(--text-secondary);
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 80px;
        }

        .heatmap-header.row-label {
            text-align: right;
            padding-right: 10px;
        }

        .heatmap-cell {
            padding: 6px 8px;
            text-align: center;
            border-radius: 2px;
            cursor: default;
            min-width: 40px;
        }

        .heatmap-cell.diagonal {
            background: rgba(45, 74, 111, 0.3);
            color: var(--text-secondary);
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-top: 16px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .legend-scale {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-box {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>CV Analytics Dashboard</h1>
    <p class="header-info">Training data coverage, accuracy metrics, and confusion analysis</p>

    <nav class="page-nav">
        <a href="cv-validator.html">üîç Validator</a>
        <a href="cv-performance.html">‚ö° Performance</a>
        <a href="training-validator.html">üéØ Training Data</a>
    </nav>

    <div class="actions">
        <button onclick="loadAnalytics()" class="primary">Refresh Data</button>
        <button onclick="exportReport()">Export Report</button>
    </div>

    <div id="loading" class="loading">Loading analytics data...</div>
    <div id="error" class="error" style="display: none;"></div>

    <div id="dashboard" style="display: none;">
        <!-- Summary Stats -->
        <div class="dashboard-grid">
            <div class="stat-card">
                <h3>Total Items</h3>
                <div class="stat-value" id="total-items">--</div>
                <div class="stat-detail" id="items-detail">-- with training data</div>
            </div>
            <div class="stat-card">
                <h3>Total Samples</h3>
                <div class="stat-value" id="total-samples">--</div>
                <div class="stat-detail" id="samples-detail">Across -- resolutions</div>
            </div>
            <div class="stat-card">
                <h3>Coverage</h3>
                <div class="stat-value" id="coverage-percent">--</div>
                <div class="stat-detail" id="coverage-detail">-- items missing samples</div>
            </div>
            <div class="stat-card">
                <h3>Avg Samples/Item</h3>
                <div class="stat-value" id="avg-samples">--</div>
                <div class="stat-detail" id="avg-detail">Target: 5+ per item</div>
            </div>
        </div>

        <!-- Coverage by Source - Chart -->
        <div class="section">
            <h2>Samples by Source</h2>
            <div class="chart-wrapper small">
                <canvas id="source-chart"></canvas>
            </div>
            <div id="source-breakdown" class="resolution-breakdown" style="margin-top: 16px;"></div>
        </div>

        <!-- Coverage by Resolution - Chart -->
        <div class="section">
            <h2>Samples by Resolution</h2>
            <div class="chart-wrapper small">
                <canvas id="resolution-chart"></canvas>
            </div>
            <div id="resolution-breakdown" class="resolution-breakdown" style="margin-top: 16px;"></div>
        </div>

        <!-- Items with Low Coverage -->
        <div class="section">
            <h2>Items Needing More Samples</h2>
            <p style="color: var(--text-secondary); margin-bottom: 16px;">Items with fewer than 3 training samples</p>
            <div class="table-container">
                <table id="low-coverage-table">
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Samples</th>
                            <th>Coverage</th>
                            <th>Sources</th>
                        </tr>
                    </thead>
                    <tbody id="low-coverage-body"></tbody>
                </table>
            </div>
        </div>

        <!-- Confusion Matrix Heatmap -->
        <div class="section">
            <h2>Confusion Matrix</h2>
            <p style="color: var(--text-secondary); margin-bottom: 16px;">
                Visual heatmap of misclassifications. Darker cells indicate more frequent confusions.
            </p>
            <div id="confusion-heatmap" class="confusion-heatmap-container"></div>
        </div>

        <!-- Commonly Confused Items - Table -->
        <div class="section">
            <h2>Common Misclassifications (Table)</h2>
            <p style="color: var(--text-secondary); margin-bottom: 16px;">Items frequently confused with each other (from correction history)</p>
            <div class="table-container">
                <table id="confusion-table">
                    <thead>
                        <tr>
                            <th>Detected As</th>
                            <th>Actually Was</th>
                            <th>Count</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody id="confusion-body"></tbody>
                </table>
            </div>
        </div>

        <!-- All Items Coverage -->
        <div class="section">
            <h2>All Items Coverage</h2>
            <div class="table-container">
                <table id="all-items-table">
                    <thead>
                        <tr>
                            <th onclick="sortTable('name')">Item</th>
                            <th onclick="sortTable('samples')">Samples</th>
                            <th onclick="sortTable('coverage')">Coverage</th>
                            <th onclick="sortTable('resolutions')">Resolutions</th>
                        </tr>
                    </thead>
                    <tbody id="all-items-body"></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // HTML escape helper to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Data holders
        let trainingIndex = null;
        let validatedExports = [];
        let itemsData = null;

        // Chart instances
        let sourceChart = null;
        let resolutionChart = null;

        // Load all analytics data
        async function loadAnalytics() {
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            const dashboard = document.getElementById('dashboard');

            loading.style.display = 'block';
            error.style.display = 'none';
            dashboard.style.display = 'none';

            try {
                // Load training index
                try {
                    const indexResp = await fetch('../../data/training-data/index.json');
                    if (indexResp.ok) {
                        trainingIndex = await indexResp.json();
                    }
                } catch (e) {
                    console.log('No training index found');
                    trainingIndex = { items: {}, sources: {} };
                }

                // Load items data for full item list
                try {
                    const itemsResp = await fetch('../../data/items.json');
                    if (itemsResp.ok) {
                        itemsData = await itemsResp.json();
                    }
                } catch (e) {
                    console.log('Could not load items.json');
                }

                // Load validated exports for confusion analysis
                validatedExports = await loadValidatedExports();

                // Render dashboard
                renderDashboard();

                loading.style.display = 'none';
                dashboard.style.display = 'block';
            } catch (e) {
                loading.style.display = 'none';
                error.style.display = 'block';
                error.textContent = `Error loading data: ${e.message}`;
            }
        }

        async function loadValidatedExports() {
            // Try to load from validated-exports directory
            // Since browsers can't list directories, we use multiple strategies
            const exports = [];

            // Strategy 1: Try to load manifest file (if it exists)
            try {
                const manifestResp = await fetch('../../validated-exports/manifest.json');
                if (manifestResp.ok) {
                    const manifest = await manifestResp.json();
                    for (const file of manifest.files || []) {
                        try {
                            const resp = await fetch(`../../validated-exports/${file}`);
                            if (resp.ok) {
                                exports.push(await resp.json());
                            }
                        } catch (e) { /* skip */ }
                    }
                    if (exports.length > 0) return exports;
                }
            } catch (e) { /* no manifest, try other strategies */ }

            // Strategy 2: Get file list from training index sources
            if (trainingIndex?.sources) {
                const sourceFiles = new Set();
                for (const [sourceName, sourceData] of Object.entries(trainingIndex.sources)) {
                    if (sourceData.source_file) {
                        sourceFiles.add(sourceData.source_file);
                    }
                }
                for (const file of sourceFiles) {
                    try {
                        // Try both relative paths
                        const paths = [
                            `../../validated-exports/${file}`,
                            `../../${file}`,
                        ];
                        for (const path of paths) {
                            const resp = await fetch(path);
                            if (resp.ok) {
                                exports.push(await resp.json());
                                break;
                            }
                        }
                    } catch (e) { /* skip */ }
                }
                if (exports.length > 0) return exports;
            }

            // Note: Browser fetch cannot scan directories or use wildcards
            // For full export discovery, create validated-exports/manifest.json
            if (exports.length === 0) {
                console.log('Tip: Create validated-exports/manifest.json with { "files": ["file1.json", ...] } for automatic discovery');
            }
            return exports;
        }

        function renderDashboard() {
            // Calculate stats
            const items = trainingIndex?.items || {};
            const allItemNames = itemsData?.items?.map(i => i.name) || Object.keys(items);

            const totalItems = allItemNames.length;
            const itemsWithData = Object.keys(items).filter(id => items[id].sample_count > 0).length;
            const totalSamples = Object.values(items).reduce((sum, item) => sum + (item.sample_count || 0), 0);

            // Get unique resolutions
            const resolutions = new Set();
            for (const item of Object.values(items)) {
                for (const sample of (item.samples || [])) {
                    if (sample.source_resolution) {
                        resolutions.add(sample.source_resolution);
                    }
                }
            }

            // Calculate average
            const avgSamples = itemsWithData > 0 ? (totalSamples / itemsWithData).toFixed(1) : 0;
            const coveragePercent = totalItems > 0 ? Math.round((itemsWithData / totalItems) * 100) : 0;

            // Update summary cards
            document.getElementById('total-items').textContent = totalItems;
            document.getElementById('items-detail').textContent = `${itemsWithData} with training data`;

            document.getElementById('total-samples').textContent = totalSamples;
            document.getElementById('samples-detail').textContent = `Across ${resolutions.size} resolutions`;

            const coverageEl = document.getElementById('coverage-percent');
            coverageEl.textContent = coveragePercent + '%';
            coverageEl.className = 'stat-value ' + (coveragePercent >= 80 ? 'good' : coveragePercent >= 50 ? 'warning' : 'bad');
            document.getElementById('coverage-detail').textContent = `${totalItems - itemsWithData} items missing samples`;

            const avgEl = document.getElementById('avg-samples');
            avgEl.textContent = avgSamples;
            avgEl.className = 'stat-value ' + (avgSamples >= 5 ? 'good' : avgSamples >= 2 ? 'warning' : 'bad');

            // Source breakdown with chart
            renderSourceBreakdown();

            // Resolution breakdown with chart
            renderResolutionBreakdown(resolutions);

            // Low coverage items
            renderLowCoverageTable(allItemNames, items);

            // Confusion heatmap
            renderConfusionHeatmap();

            // Confusion table
            renderConfusionTable();

            // All items table
            renderAllItemsTable(allItemNames, items);
        }

        function renderSourceBreakdown() {
            const container = document.getElementById('source-breakdown');
            const canvas = document.getElementById('source-chart');
            const sources = trainingIndex?.sources || {};

            // Destroy existing chart
            if (sourceChart) {
                sourceChart.destroy();
                sourceChart = null;
            }

            const sourceEntries = Object.entries(sources).sort((a, b) => (b[1].sample_count || 0) - (a[1].sample_count || 0));

            if (sourceEntries.length === 0) {
                canvas.parentElement.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">üìÅ</div>
                        <h3>No Source Data</h3>
                        <p>Import validated screenshots to see source breakdown.</p>
                    </div>
                `;
                container.innerHTML = '';
                return;
            }

            // Create bar chart
            const ctx = canvas.getContext('2d');
            const colors = ['#e94560', '#4ade80', '#06b6d4', '#fbbf24', '#a855f7', '#f97316'];

            sourceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sourceEntries.map(([name]) => name),
                    datasets: [{
                        label: 'Samples',
                        data: sourceEntries.map(([, data]) => data.sample_count || 0),
                        backgroundColor: sourceEntries.map((_, i) => colors[i % colors.length] + '80'),
                        borderColor: sourceEntries.map((_, i) => colors[i % colors.length]),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(22, 33, 62, 0.95)',
                            titleColor: '#e0e0e0',
                            bodyColor: '#a0a0a0',
                            borderColor: '#2d4a6f',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(45, 74, 111, 0.3)' },
                            ticks: { color: '#a0a0a0' }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#e0e0e0' }
                        }
                    }
                }
            });

            // Also render tags
            container.innerHTML = '';
            for (const [source, data] of sourceEntries) {
                const tag = document.createElement('div');
                tag.className = 'resolution-tag';
                tag.innerHTML = `${escapeHtml(source)}: <span class="count">${data.sample_count || 0}</span>`;
                container.appendChild(tag);
            }
        }

        function renderResolutionBreakdown(resolutions) {
            const container = document.getElementById('resolution-breakdown');
            const canvas = document.getElementById('resolution-chart');
            const items = trainingIndex?.items || {};

            // Destroy existing chart
            if (resolutionChart) {
                resolutionChart.destroy();
                resolutionChart = null;
            }

            // Count samples per resolution
            const resCounts = {};
            for (const item of Object.values(items)) {
                for (const sample of (item.samples || [])) {
                    const res = sample.source_resolution || 'unknown';
                    resCounts[res] = (resCounts[res] || 0) + 1;
                }
            }

            const resEntries = Object.entries(resCounts).sort((a, b) => b[1] - a[1]);

            if (resEntries.length === 0) {
                canvas.parentElement.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">üìê</div>
                        <h3>No Resolution Data</h3>
                        <p>Resolution data will appear after importing validated screenshots.</p>
                    </div>
                `;
                container.innerHTML = '';
                return;
            }

            // Create doughnut chart
            const ctx = canvas.getContext('2d');
            const colors = ['#e94560', '#4ade80', '#06b6d4', '#fbbf24', '#a855f7', '#f97316', '#10b981', '#8b5cf6'];

            resolutionChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: resEntries.map(([res]) => res),
                    datasets: [{
                        data: resEntries.map(([, count]) => count),
                        backgroundColor: resEntries.map((_, i) => colors[i % colors.length] + '80'),
                        borderColor: resEntries.map((_, i) => colors[i % colors.length]),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#e0e0e0',
                                padding: 12,
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(22, 33, 62, 0.95)',
                            titleColor: '#e0e0e0',
                            bodyColor: '#a0a0a0',
                            borderColor: '#2d4a6f',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const pct = ((context.parsed / total) * 100).toFixed(1);
                                    return `${context.label}: ${context.parsed} (${pct}%)`;
                                }
                            }
                        }
                    }
                }
            });

            // Also render tags
            container.innerHTML = '';
            for (const [res, count] of resEntries) {
                const tag = document.createElement('div');
                tag.className = 'resolution-tag';
                tag.innerHTML = `${escapeHtml(res)}: <span class="count">${count}</span>`;
                container.appendChild(tag);
            }
        }

        function renderLowCoverageTable(allItemNames, items) {
            const tbody = document.getElementById('low-coverage-body');
            tbody.innerHTML = '';

            // Build item coverage data
            const coverageData = [];

            for (const name of allItemNames) {
                const id = name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
                const item = items[id];
                const sampleCount = item?.sample_count || 0;

                if (sampleCount < 3) {
                    const sources = new Set();
                    for (const sample of (item?.samples || [])) {
                        sources.add(sample.source || 'unknown');
                    }

                    coverageData.push({
                        name,
                        samples: sampleCount,
                        sources: [...sources].join(', ') || 'none',
                    });
                }
            }

            // Sort by samples ascending
            coverageData.sort((a, b) => a.samples - b.samples);

            // Render rows (limit to 20)
            for (const item of coverageData.slice(0, 20)) {
                const row = document.createElement('tr');
                const coverageClass = item.samples === 0 ? 'low' : item.samples < 2 ? 'medium' : 'high';
                row.innerHTML = `
                    <td>${escapeHtml(item.name)}</td>
                    <td>${item.samples}</td>
                    <td>
                        <div class="coverage-bar">
                            <div class="coverage-fill ${escapeHtml(coverageClass)}" style="width: ${Math.min(100, item.samples * 20)}%"></div>
                        </div>
                        ${item.samples}/5
                    </td>
                    <td>${escapeHtml(item.sources)}</td>
                `;
                tbody.appendChild(row);
            }

            if (coverageData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--text-secondary);">All items have sufficient coverage!</td></tr>';
            }
        }

        function renderConfusionHeatmap() {
            const container = document.getElementById('confusion-heatmap');

            // Analyze validated exports for corrections
            const confusions = new Map();
            const allItems = new Set();

            for (const exp of validatedExports) {
                for (const slot of Object.values(exp.slots || {})) {
                    if (slot.was_corrected && slot.original_detection && slot.item) {
                        const detected = slot.original_detection;
                        const actual = slot.item;
                        const key = `${detected}|${actual}`;
                        const current = confusions.get(key) || { detected, actual, count: 0 };
                        current.count++;
                        confusions.set(key, current);
                        allItems.add(detected);
                        allItems.add(actual);
                    }
                }
            }

            if (confusions.size === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">üîç</div>
                        <h3>No Confusion Data Yet</h3>
                        <p>Confusion data is collected from validated screenshots where corrections were made.</p>
                        <p>Complete some validations with corrections to see the heatmap.</p>
                    </div>
                `;
                return;
            }

            // Get top items involved in confusions (limit to 10 for readability)
            const itemCounts = new Map();
            for (const item of allItems) {
                itemCounts.set(item, 0);
            }
            for (const conf of confusions.values()) {
                itemCounts.set(conf.detected, (itemCounts.get(conf.detected) || 0) + conf.count);
                itemCounts.set(conf.actual, (itemCounts.get(conf.actual) || 0) + conf.count);
            }

            const topItems = [...itemCounts.entries()]
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([item]) => item);

            // Find max confusion count for intensity scaling
            const maxCount = Math.max(...[...confusions.values()].map(c => c.count), 1);

            // Build the heatmap grid
            const cols = topItems.length + 1; // +1 for row labels
            let html = `<div class="confusion-heatmap" style="grid-template-columns: 100px repeat(${topItems.length}, 1fr);">`;

            // Header row (column labels)
            html += '<div class="heatmap-header"></div>'; // Empty corner cell
            for (const item of topItems) {
                const shortName = item.length > 12 ? item.slice(0, 10) + '...' : item;
                html += `<div class="heatmap-header" title="${escapeHtml(item)}">${escapeHtml(shortName)}</div>`;
            }

            // Data rows
            for (const rowItem of topItems) {
                const shortRowName = rowItem.length > 12 ? rowItem.slice(0, 10) + '...' : rowItem;
                html += `<div class="heatmap-header row-label" title="${escapeHtml(rowItem)}">${escapeHtml(shortRowName)}</div>`;

                for (const colItem of topItems) {
                    if (rowItem === colItem) {
                        // Diagonal - self confusion doesn't make sense
                        html += '<div class="heatmap-cell diagonal">-</div>';
                    } else {
                        const key = `${rowItem}|${colItem}`;
                        const conf = confusions.get(key);
                        const count = conf?.count || 0;

                        // Calculate intensity (0-5 scale)
                        const intensity = count === 0 ? 0 : Math.min(5, Math.ceil((count / maxCount) * 5));

                        html += `<div class="heatmap-cell intensity-${intensity}" title="${escapeHtml(rowItem)} ‚Üí ${escapeHtml(colItem)}: ${count}">${count || ''}</div>`;
                    }
                }
            }

            html += '</div>';

            // Add legend
            html += `
                <div class="heatmap-legend">
                    <span>Confusion frequency:</span>
                    <div class="legend-scale">
                        <div class="legend-box intensity-0"></div>
                        <span>None</span>
                    </div>
                    <div class="legend-scale">
                        <div class="legend-box intensity-1"></div>
                        <span>Low</span>
                    </div>
                    <div class="legend-scale">
                        <div class="legend-box intensity-3"></div>
                        <span>Medium</span>
                    </div>
                    <div class="legend-scale">
                        <div class="legend-box intensity-5"></div>
                        <span>High</span>
                    </div>
                </div>
                <p style="margin-top: 12px; font-size: 11px; color: var(--text-secondary);">
                    Rows = Detected as | Columns = Actually was
                </p>
            `;

            container.innerHTML = html;
        }

        function renderConfusionTable() {
            const tbody = document.getElementById('confusion-body');
            tbody.innerHTML = '';

            // Analyze validated exports for corrections
            const confusions = new Map();

            for (const exp of validatedExports) {
                for (const slot of Object.values(exp.slots || {})) {
                    if (slot.was_corrected && slot.original_detection && slot.item) {
                        const key = `${slot.original_detection}|${slot.item}`;
                        const current = confusions.get(key) || { detected: slot.original_detection, actual: slot.item, count: 0 };
                        current.count++;
                        confusions.set(key, current);
                    }
                }
            }

            // Sort by count
            const sortedConfusions = [...confusions.values()].sort((a, b) => b.count - a.count);

            // Render rows
            for (const conf of sortedConfusions.slice(0, 15)) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${escapeHtml(conf.detected)}</td>
                    <td>${escapeHtml(conf.actual)}</td>
                    <td>${conf.count}</td>
                    <td style="color: var(--text-secondary);">May need more training samples</td>
                `;
                tbody.appendChild(row);
            }

            if (sortedConfusions.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--text-secondary);">No confusion data yet. Complete some validations first.</td></tr>';
            }
        }

        function renderAllItemsTable(allItemNames, items) {
            const tbody = document.getElementById('all-items-body');
            tbody.innerHTML = '';

            const rows = [];

            for (const name of allItemNames) {
                const id = name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
                const item = items[id];
                const sampleCount = item?.sample_count || 0;
                const resolutions = item?.resolutions || {};
                const resCount = Object.keys(resolutions).length;

                rows.push({
                    name,
                    samples: sampleCount,
                    resolutions: resCount,
                });
            }

            // Sort by samples ascending by default
            rows.sort((a, b) => a.samples - b.samples);

            for (const item of rows) {
                const row = document.createElement('tr');
                const coverageClass = item.samples === 0 ? 'low' : item.samples < 3 ? 'medium' : 'high';
                row.innerHTML = `
                    <td>${escapeHtml(item.name)}</td>
                    <td>${item.samples}</td>
                    <td>
                        <div class="coverage-bar">
                            <div class="coverage-fill ${escapeHtml(coverageClass)}" style="width: ${Math.min(100, item.samples * 10)}%"></div>
                        </div>
                    </td>
                    <td>${item.resolutions}</td>
                `;
                tbody.appendChild(row);
            }
        }

        function exportReport() {
            const items = trainingIndex?.items || {};
            const report = {
                generated_at: new Date().toISOString(),
                summary: {
                    total_items: Object.keys(items).length,
                    total_samples: Object.values(items).reduce((s, i) => s + (i.sample_count || 0), 0),
                },
                items: Object.entries(items).map(([id, item]) => ({
                    id,
                    name: item.name,
                    samples: item.sample_count,
                    resolutions: Object.keys(item.resolutions || {}),
                })),
            };

            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cv-analytics-report-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Load on page load
        loadAnalytics();
    </script>
</body>
</html>
