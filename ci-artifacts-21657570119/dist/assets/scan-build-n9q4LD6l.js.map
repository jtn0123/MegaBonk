{"version":3,"mappings":"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","names":["async","createDebugOverlay","imageDataUrl","detections","width","height","loadImageToCanvas","scanRegions","x","y","Math","floor","label","canvas","document","createElement","ctx","getContext","logger","warn","operation","data","canvasWidth","canvasHeight","img","Promise","resolve","reject","image","Image","onload","onerror","event","errorMsg","ErrorEvent","message","imageUrlLength","length","error","Error","src","drawImage","lineWidth","setLineDash","strokeStyle","font","forEach","region","strokeRect","fillStyle","labelText","replace","toUpperCase","fillRect","measureText","fillText","detection","position","pos","confidence","color","entity","name","confidenceText","toFixed","labelWidth","max","legendX","legendY","renderDebugOverlay","toDataURL","stack","split","slice","join","detectionsCount","extractErrorInfo","stackLines","String","logError","logWarning","showItemSelectionGrid","allData","onCharacterSelect","onWeaponSelect","onItemCountChange","onTomeToggle","updateSummary","selectionContainer","getElementById","style","display","createEntitySelection","characters","weapons","container","items","innerHTML","searchBox","type","className","placeholder","addEventListener","e","query","gridContainer","cards","querySelectorAll","card","dataset","includes","filterItemGrid","target","value","toLowerCase","appendChild","id","item","info","escapeHtml","tier","controls","decrementBtn","textContent","setAttribute","countDisplay","incrementBtn","updateCount","delta","newCount","toString","classList","remove","add","createItemCard","createItemGrid","tomes","tome","contains","createTomeGrid","entities","onSelect","c","highlightDetectedEntity","entityId","gridId","grid","querySelector","runHybridDetect","uploadedImage","detectionMutex","templatesLoaded","templatesLoadError","onResults","tryAcquire","ToastManager","release","warning","progress","createProgressIndicator","previewContainer","element","update","ocrResults","autoDetectFromImage","pct","status","cvResults","detectItemsWithCV","hybridResults","cvAsOCR","map","cv","rawText","combinedItems","combineDetections","filter","r","combinedTomes","aggregatedItems","aggregateDuplicates","aggregatedTomes","character","charResult","find","weapon","weaponResult","method","count","combineHybridResults","updateStats","updateLogViewer","isDebugEnabled","debugOverlayUrl","setLastOverlayUrl","imagePreview","success","displayDebugOverlay","itemsDetected","tomesDetected","characterDetected","weaponDetected","ocrItems","cvItems","getConfidenceClass","applyDetectionResults","results","state","showGrid","selectedItems","clear","selectedTomes","selectedCharacter","selectedWeapon","itemCounts","Map","currentCount","get","set","itemId","i","updateItemCardCount","uniqueTomes","Set","has","allDetections","highCount","d","mediumCount","lowCount","avgConfidence","reduce","sum","html","round","confClass","displayDetectionConfidence","eventListenerManager","createEventListenerManager","uploadDebouncer","fn","delayMs","timeoutId","pendingId","call","args","clearTimeout","currentId","setTimeout","result","cancel","createDebouncedAsync","file","reader","FileReader","onClearImage","wrapper","alt","clearBtn","autoDetectArea","displayUploadedImage","clearUploadedImage","readAsDataURL","fileName","fileSize","size","fileType","locked","isLocked","withLock","createMutex","onBuildStateChange","getSelectionState","initScanBuild","gameData","stateChangeCallback","initOCR","initCV","hybridBtn","disabled","title","loadItemTemplates","then","catch","itemsCount","phase","cleanupEventListeners","uploadBtn","addWithSignal","handleUploadClick","fileInput","handleFileSelect","applyBtn","handleApplyToAdvisor","autoDetectBtn","handleAutoDetect","hybridDetectBtn","handleHybridDetect","setupEventListeners","removeAll","click","input","files","startsWith","MAX_FILE_SIZE_BYTES","detectionInfo","clearImageDisplay","handleItemCountChange","current","min","MAX_ITEM_COUNT","delete","handleCharacterSelect","handleWeaponSelect","handleTomeToggle","selected","summaryContainer","updateSelectionSummary","handleDetectionResults","cvError","runAutoDetect","push","buildState","Array","from","values","windowWithApply","window","applyScannedBuild","tomesCount","advisorSection","scrollIntoView","behavior","block","applyToAdvisor","getState","entries","t","__resetForTesting","getAllData","import","n","L","__VITE_PRELOAD__","existingData","Object","keys","debug"],"ignoreList":[],"sources":["../../src/modules/cv/debug.ts","../../src/modules/error-utils.ts","../../src/modules/scan-build-ui.ts","../../src/modules/scan-build-detection.ts","../../src/modules/scan-build-results.ts","../../src/modules/scan-build.ts","../../src/modules/async-utils.ts"],"sourcesContent":["// ========================================\n// CV Debug Visualization\n// ========================================\n\nimport type { CVDetectionResult, ROI } from './types.ts';\nimport { loadImageToCanvas } from './detection.ts';\nimport { logger } from '../logger.ts';\n\n/**\n * Render debug overlay showing scan regions and detections\n * Draws colored boxes around detections with confidence scores\n */\nexport async function renderDebugOverlay(\n    canvas: HTMLCanvasElement,\n    imageDataUrl: string,\n    scanRegions: ROI[],\n    detections: CVDetectionResult[],\n    _emptyCells?: Set<number> // Deprecated, kept for compatibility\n): Promise<void> {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        logger.warn({\n            operation: 'cv.debug.render_overlay_no_context',\n            data: { canvasWidth: canvas.width, canvasHeight: canvas.height },\n        });\n        return;\n    }\n\n    // Wait for image to load properly (fixes race condition)\n    const img = await new Promise<HTMLImageElement>((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.onerror = (event) => {\n            const errorMsg = event instanceof ErrorEvent ? event.message : 'Unknown image load error';\n            logger.warn({\n                operation: 'cv.debug.image_load_failed',\n                data: { imageUrlLength: imageDataUrl.length, error: errorMsg },\n            });\n            reject(new Error(`Failed to load image for debug overlay: ${errorMsg}`));\n        };\n        image.src = imageDataUrl;\n    });\n\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n\n    // Draw scan regions (dashed cyan boxes)\n    ctx.lineWidth = 2;\n    ctx.setLineDash([10, 5]);\n    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)'; // Cyan, semi-transparent\n    ctx.font = '14px monospace';\n\n    scanRegions.forEach(region => {\n        ctx.strokeRect(region.x, region.y, region.width, region.height);\n\n        // Label the region\n        if (region.label) {\n            ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';\n            const labelText = region.label.replace('_', ' ').toUpperCase();\n            ctx.fillRect(region.x, region.y - 20, ctx.measureText(labelText).width + 10, 20);\n            ctx.fillStyle = 'black';\n            ctx.fillText(labelText, region.x + 5, region.y - 5);\n        }\n    });\n\n    // Reset line dash for detections\n    ctx.setLineDash([]);\n\n    // Draw detections with confidence-based colors\n    detections.forEach(detection => {\n        if (!detection.position) return;\n\n        const pos = detection.position;\n        const confidence = detection.confidence;\n\n        // Color based on confidence\n        let color: string;\n        if (confidence >= 0.85) {\n            color = 'rgba(0, 255, 0, 0.8)'; // Green = high confidence\n        } else if (confidence >= 0.7) {\n            color = 'rgba(255, 165, 0, 0.8)'; // Orange = medium confidence\n        } else {\n            color = 'rgba(255, 0, 0, 0.8)'; // Red = low confidence\n        }\n\n        // Draw detection border (thicker)\n        ctx.lineWidth = 3;\n        ctx.strokeStyle = color;\n        ctx.strokeRect(pos.x, pos.y, pos.width, pos.height);\n\n        // Draw label background\n        const label = `${detection.entity.name}`;\n        const confidenceText = `${(confidence * 100).toFixed(0)}%`;\n        const labelWidth = Math.max(ctx.measureText(label).width, ctx.measureText(confidenceText).width) + 10;\n\n        ctx.fillStyle = color;\n        ctx.fillRect(pos.x, pos.y + pos.height, labelWidth, 36);\n\n        // Draw label text\n        ctx.fillStyle = 'black';\n        ctx.font = 'bold 12px monospace';\n        ctx.fillText(label, pos.x + 5, pos.y + pos.height + 14);\n        ctx.fillText(confidenceText, pos.x + 5, pos.y + pos.height + 30);\n    });\n\n    // Draw legend\n    const legendX = 10;\n    const legendY = 10;\n    const legendHeight = 140;\n\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    ctx.fillRect(legendX, legendY, 220, legendHeight);\n\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 14px monospace';\n    ctx.fillText('Smart Detection Overlay', legendX + 10, legendY + 20);\n\n    ctx.font = '12px monospace';\n    ctx.fillStyle = 'rgba(0, 255, 0, 1)';\n    ctx.fillText('■ High (≥85%)', legendX + 10, legendY + 45);\n\n    ctx.fillStyle = 'rgba(255, 165, 0, 1)';\n    ctx.fillText('■ Medium (70-85%)', legendX + 10, legendY + 65);\n\n    ctx.fillStyle = 'rgba(255, 0, 0, 1)';\n    ctx.fillText('■ Low (<70%)', legendX + 10, legendY + 85);\n\n    ctx.fillStyle = 'rgba(0, 255, 255, 1)';\n    ctx.fillText('┄ Scan regions', legendX + 10, legendY + 105);\n\n    ctx.fillStyle = 'rgba(200, 200, 200, 1)';\n    ctx.fillText(`Detections: ${detections.length}`, legendX + 10, legendY + 125);\n}\n\n/**\n * Create debug overlay canvas and return as data URL\n * Shows scan regions and detected icons with confidence scores\n * Returns a fallback placeholder image URL if creation fails\n */\nexport async function createDebugOverlay(imageDataUrl: string, detections: CVDetectionResult[]): Promise<string> {\n    try {\n        const { width, height } = await loadImageToCanvas(imageDataUrl);\n\n        // Define scan regions (same as used in detectItemsWithCV)\n        const scanRegions: ROI[] = [\n            {\n                x: 0,\n                y: Math.floor(height * 0.8),\n                width: width,\n                height: Math.floor(height * 0.2),\n                label: 'hotbar_region',\n            },\n            {\n                x: 0,\n                y: 0,\n                width: Math.floor(width * 0.25),\n                height: Math.floor(height * 0.4),\n                label: 'equipment_region',\n            },\n        ];\n\n        // Create canvas for debug overlay\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n\n        // Wait for debug overlay to fully render\n        await renderDebugOverlay(canvas, imageDataUrl, scanRegions, detections);\n\n        return canvas.toDataURL('image/png');\n    } catch (error) {\n        logger.error({\n            operation: 'cv.debug.create_overlay_failed',\n            error: {\n                name: (error as Error).name,\n                message: (error as Error).message,\n                stack: (error as Error).stack?.split('\\n').slice(0, 3).join(' -> '),\n            },\n            data: {\n                imageUrlLength: imageDataUrl.length,\n                detectionsCount: detections.length,\n            },\n        });\n        // Return the original image as fallback instead of failing completely\n        return imageDataUrl;\n    }\n}\n\n// ========================================\n// Enhanced Debug Visualizations\n// ========================================\n\n/**\n * Debug visualization options\n */\nexport interface DebugVisualizationOptions {\n    showGrid: boolean;\n    showConfidenceHeatmap: boolean;\n    showMatchingSteps: boolean;\n    confidenceThreshold: number;\n    gridCellSize: number;\n}\n\nexport const defaultDebugOptions: DebugVisualizationOptions = {\n    showGrid: true,\n    showConfidenceHeatmap: false,\n    showMatchingSteps: false,\n    confidenceThreshold: 0.7,\n    gridCellSize: 64,\n};\n\n/**\n * Render live grid overlay during scanning\n * Shows the cell grid being scanned in real-time\n */\nexport function renderGridOverlay(\n    canvas: HTMLCanvasElement,\n    gridCells: ROI[],\n    currentCell?: number,\n    processedCells?: Set<number>\n): void {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Draw grid cells\n    ctx.lineWidth = 1;\n    ctx.setLineDash([4, 4]);\n\n    gridCells.forEach((cell, index) => {\n        let color: string;\n\n        if (index === currentCell) {\n            color = 'rgba(255, 255, 0, 0.8)'; // Yellow = currently processing\n        } else if (processedCells?.has(index)) {\n            color = 'rgba(100, 100, 100, 0.4)'; // Gray = processed\n        } else {\n            color = 'rgba(150, 150, 150, 0.3)'; // Light gray = pending\n        }\n\n        ctx.strokeStyle = color;\n        ctx.strokeRect(cell.x, cell.y, cell.width, cell.height);\n\n        // Show cell index\n        ctx.fillStyle = color;\n        ctx.font = '10px monospace';\n        ctx.fillText(`${index}`, cell.x + 2, cell.y + 12);\n    });\n\n    ctx.setLineDash([]);\n}\n\n/**\n * Render confidence heatmap overlay\n * Shows detection confidence as a color gradient\n */\nexport function renderConfidenceHeatmap(\n    canvas: HTMLCanvasElement,\n    detections: CVDetectionResult[],\n    threshold: number = 0.7\n): void {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Group detections by confidence bands\n    const bands = [\n        { min: 0.9, max: 1.0, color: 'rgba(0, 255, 0, 0.3)' },\n        { min: 0.8, max: 0.9, color: 'rgba(128, 255, 0, 0.3)' },\n        { min: 0.7, max: 0.8, color: 'rgba(255, 255, 0, 0.3)' },\n        { min: threshold, max: 0.7, color: 'rgba(255, 165, 0, 0.3)' },\n        { min: 0, max: threshold, color: 'rgba(255, 0, 0, 0.3)' },\n    ];\n\n    detections.forEach(detection => {\n        if (!detection.position) return;\n\n        const pos = detection.position;\n        const confidence = detection.confidence;\n\n        // Find matching band\n        const band = bands.find(b => confidence >= b.min && confidence < b.max);\n        if (band) {\n            ctx.fillStyle = band.color;\n            ctx.fillRect(pos.x, pos.y, pos.width, pos.height);\n        }\n    });\n}\n\n/**\n * Render step-by-step template matching view\n * Shows the matching process for debugging\n */\nexport interface MatchingStep {\n    templateId: string;\n    templateName: string;\n    similarity: number;\n    position: ROI;\n    isMatch: boolean;\n}\n\nexport function renderMatchingSteps(canvas: HTMLCanvasElement, steps: MatchingStep[], currentStep: number): void {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Clear previous steps display\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';\n    ctx.fillRect(10, canvas.height - 200, 300, 190);\n\n    // Header\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 14px monospace';\n    ctx.fillText('Template Matching Steps', 20, canvas.height - 180);\n\n    // Show recent steps\n    ctx.font = '11px monospace';\n    const displaySteps = steps.slice(Math.max(0, currentStep - 7), currentStep + 1);\n\n    displaySteps.forEach((step, i) => {\n        const y = canvas.height - 160 + i * 20;\n        const isLatest = i === displaySteps.length - 1;\n\n        // Background for latest step\n        if (isLatest) {\n            ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';\n            ctx.fillRect(15, y - 12, 290, 18);\n        }\n\n        // Match indicator\n        ctx.fillStyle = step.isMatch ? 'rgba(0, 255, 0, 1)' : 'rgba(255, 0, 0, 1)';\n        ctx.fillText(step.isMatch ? '✓' : '✗', 20, y);\n\n        // Template name and similarity\n        ctx.fillStyle = 'white';\n        const text = `${step.templateName.slice(0, 15).padEnd(15)} ${(step.similarity * 100).toFixed(1)}%`;\n        ctx.fillText(text, 40, y);\n    });\n\n    // Progress indicator\n    ctx.fillStyle = 'rgba(100, 100, 255, 1)';\n    ctx.fillText(`Step ${currentStep + 1}/${steps.length}`, 220, canvas.height - 180);\n}\n\n/**\n * Render side-by-side strategy comparison\n * Compares results from different CV strategies\n */\nexport interface StrategyResult {\n    strategyName: string;\n    detections: CVDetectionResult[];\n    processingTime: number;\n    accuracy?: number;\n}\n\nexport async function renderStrategyComparison(\n    canvas: HTMLCanvasElement,\n    imageDataUrl: string,\n    results: StrategyResult[]\n): Promise<void> {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Load image\n    const img = await new Promise<HTMLImageElement>((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.onerror = () => reject(new Error('Failed to load image'));\n        image.src = imageDataUrl;\n    });\n\n    // Calculate layout\n    const numStrategies = results.length;\n    const colWidth = Math.floor(img.width / numStrategies);\n    canvas.width = img.width;\n    canvas.height = img.height + 80; // Extra space for labels\n\n    // Draw comparison panel\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';\n    ctx.fillRect(0, 0, canvas.width, 80);\n\n    // Draw header\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 16px monospace';\n    ctx.fillText('Strategy Comparison', 10, 25);\n\n    results.forEach((result, index) => {\n        const x = index * colWidth;\n\n        // Draw strategy header\n        ctx.fillStyle = 'rgba(50, 50, 50, 1)';\n        ctx.fillRect(x, 35, colWidth - 5, 40);\n\n        ctx.fillStyle = 'white';\n        ctx.font = '12px monospace';\n        ctx.fillText(result.strategyName, x + 5, 52);\n        ctx.fillText(`${result.detections.length} items | ${result.processingTime}ms`, x + 5, 68);\n\n        // Draw image section\n        ctx.drawImage(img, x, 80, colWidth, img.height);\n\n        // Draw detections for this strategy\n        result.detections.forEach(detection => {\n            if (!detection.position) return;\n\n            const pos = detection.position;\n            const confidence = detection.confidence;\n\n            const color =\n                confidence >= 0.85\n                    ? 'rgba(0, 255, 0, 0.8)'\n                    : confidence >= 0.7\n                      ? 'rgba(255, 165, 0, 0.8)'\n                      : 'rgba(255, 0, 0, 0.8)';\n\n            ctx.strokeStyle = color;\n            ctx.lineWidth = 2;\n            ctx.strokeRect(\n                x + (pos.x * colWidth) / img.width,\n                80 + pos.y,\n                (pos.width * colWidth) / img.width,\n                pos.height\n            );\n        });\n\n        // Draw separator\n        if (index < numStrategies - 1) {\n            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n            ctx.lineWidth = 1;\n            ctx.beginPath();\n            ctx.moveTo(x + colWidth - 2, 80);\n            ctx.lineTo(x + colWidth - 2, canvas.height);\n            ctx.stroke();\n        }\n    });\n}\n\n/**\n * Render confidence distribution histogram\n */\nexport function renderConfidenceHistogram(\n    canvas: HTMLCanvasElement,\n    detections: CVDetectionResult[],\n    threshold: number = 0.7\n): void {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Calculate histogram bins\n    const bins = Array(10).fill(0);\n    detections.forEach(d => {\n        const bin = Math.min(9, Math.floor(d.confidence * 10));\n        bins[bin]++;\n    });\n\n    const maxCount = Math.max(...bins, 1);\n\n    // Draw histogram panel\n    const panelX = canvas.width - 210;\n    const panelY = canvas.height - 120;\n    const panelWidth = 200;\n    const panelHeight = 110;\n\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';\n    ctx.fillRect(panelX, panelY, panelWidth, panelHeight);\n\n    // Title\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 12px monospace';\n    ctx.fillText('Confidence Distribution', panelX + 10, panelY + 15);\n\n    // Draw bars\n    const barWidth = 15;\n    const barStartX = panelX + 20;\n    const barMaxHeight = 60;\n\n    bins.forEach((count, i) => {\n        const x = barStartX + i * (barWidth + 4);\n        const height = (count / maxCount) * barMaxHeight;\n        const y = panelY + 90 - height;\n\n        // Bar color based on bin\n        const confidence = (i + 0.5) / 10;\n        ctx.fillStyle =\n            confidence >= 0.85\n                ? 'rgba(0, 255, 0, 0.8)'\n                : confidence >= 0.7\n                  ? 'rgba(255, 165, 0, 0.8)'\n                  : 'rgba(255, 0, 0, 0.8)';\n\n        ctx.fillRect(x, y, barWidth, height);\n\n        // Count label\n        if (count > 0) {\n            ctx.fillStyle = 'white';\n            ctx.font = '9px monospace';\n            ctx.fillText(String(count), x + 2, y - 2);\n        }\n    });\n\n    // Threshold line\n    const thresholdX = barStartX + threshold * 10 * (barWidth + 4);\n    ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';\n    ctx.setLineDash([3, 3]);\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(thresholdX, panelY + 25);\n    ctx.lineTo(thresholdX, panelY + 95);\n    ctx.stroke();\n    ctx.setLineDash([]);\n\n    // X-axis labels\n    ctx.fillStyle = 'rgba(150, 150, 150, 1)';\n    ctx.font = '9px monospace';\n    ctx.fillText('0%', barStartX - 5, panelY + 103);\n    ctx.fillText('100%', barStartX + 155, panelY + 103);\n}\n","// ========================================\n// MegaBonk Error Utilities Module\n// ========================================\n// Shared error handling patterns for consistent logging\n// ========================================\n\nimport { logger } from './logger.ts';\n\n/**\n * Normalized error info for logging\n */\nexport interface ErrorInfo {\n    name: string;\n    message: string;\n    stack?: string;\n}\n\n/**\n * Extract normalized error info from unknown error\n * @param error - Unknown error value\n * @param stackLines - Number of stack trace lines to include (default: 5)\n * @returns Normalized ErrorInfo object\n */\nexport function extractErrorInfo(error: unknown, stackLines: number = 5): ErrorInfo {\n    if (error instanceof Error) {\n        return {\n            name: error.name,\n            message: error.message,\n            stack: error.stack?.split('\\n').slice(0, stackLines).join(' -> '),\n        };\n    }\n\n    // Handle non-Error values\n    return {\n        name: 'UnknownError',\n        message: String(error),\n    };\n}\n\n/**\n * Log error with consistent structure\n * @param operation - Operation identifier (e.g., 'scan_build.auto_detect')\n * @param error - Error to log\n * @param data - Additional context data\n */\nexport function logError(\n    operation: string,\n    error: unknown,\n    data?: Record<string, unknown>\n): void {\n    logger.error({\n        operation,\n        error: extractErrorInfo(error),\n        data,\n    });\n}\n\n/**\n * Log warning with consistent structure\n * @param operation - Operation identifier\n * @param error - Error to log\n * @param data - Additional context data\n */\nexport function logWarning(\n    operation: string,\n    error: unknown,\n    data?: Record<string, unknown>\n): void {\n    logger.warn({\n        operation,\n        error: extractErrorInfo(error),\n        data,\n    });\n}\n\n/**\n * Wrap an async function with automatic error logging\n * @param operation - Operation identifier for logging\n * @param fn - Async function to wrap\n * @param onError - Optional callback on error (receives extracted error info)\n * @returns Wrapped function that catches and logs errors\n */\nexport function withErrorLogging<T, Args extends unknown[]>(\n    operation: string,\n    fn: (...args: Args) => Promise<T>,\n    onError?: (error: ErrorInfo) => void\n): (...args: Args) => Promise<T | undefined> {\n    return async (...args: Args): Promise<T | undefined> => {\n        try {\n            return await fn(...args);\n        } catch (error) {\n            const errorInfo = extractErrorInfo(error);\n            logError(operation, error);\n            onError?.(errorInfo);\n            return undefined;\n        }\n    };\n}\n\n/**\n * Execute function with try/catch, returning result or default on error\n * @param fn - Function to execute\n * @param defaultValue - Value to return on error\n * @param operation - Optional operation name for logging (if not provided, error is silent)\n * @returns Function result or default value\n */\nexport function tryOrDefault<T>(\n    fn: () => T,\n    defaultValue: T,\n    operation?: string\n): T {\n    try {\n        return fn();\n    } catch (error) {\n        if (operation) {\n            logWarning(operation, error);\n        }\n        return defaultValue;\n    }\n}\n\n/**\n * Execute async function with try/catch, returning result or default on error\n * @param fn - Async function to execute\n * @param defaultValue - Value to return on error\n * @param operation - Optional operation name for logging\n * @returns Promise of function result or default value\n */\nexport async function tryOrDefaultAsync<T>(\n    fn: () => Promise<T>,\n    defaultValue: T,\n    operation?: string\n): Promise<T> {\n    try {\n        return await fn();\n    } catch (error) {\n        if (operation) {\n            logWarning(operation, error);\n        }\n        return defaultValue;\n    }\n}\n","// ========================================\n// MegaBonk Scan Build - UI Module\n// ========================================\n// Handles UI rendering, DOM manipulation, element creation\n// ========================================\n\nimport type { Item, Tome, Character, Weapon, AllGameData } from '../types/index.ts';\nimport { escapeHtml } from './utils.ts';\nimport type { EventListenerManager } from './dom-utils.ts';\n\n// Types for state callbacks\nexport interface SelectionState {\n    selectedItems: Map<string, { item: Item; count: number }>;\n    selectedTomes: Map<string, Tome>;\n    selectedCharacter: Character | null;\n    selectedWeapon: Weapon | null;\n}\n\nexport type SelectionUpdateCallback = (state: SelectionState) => void;\nexport type ItemCountUpdateCallback = (item: Item, delta: number) => number;\n\n/**\n * Display the uploaded image\n * Uses DOM manipulation instead of innerHTML to prevent XSS from malformed data URLs\n */\nexport function displayUploadedImage(\n    uploadedImage: string,\n    eventListenerManager: EventListenerManager,\n    onClearImage: () => void\n): void {\n    const previewContainer = document.getElementById('scan-image-preview');\n    if (!previewContainer || !uploadedImage) return;\n\n    // Clear existing content safely\n    previewContainer.innerHTML = '';\n\n    // Create elements via DOM API to prevent XSS\n    const wrapper = document.createElement('div');\n    wrapper.className = 'scan-image-wrapper';\n\n    const img = document.createElement('img');\n    img.src = uploadedImage; // Set via property, not innerHTML\n    img.alt = 'Uploaded build screenshot';\n    img.className = 'scan-preview-image';\n\n    const clearBtn = document.createElement('button');\n    clearBtn.className = 'scan-clear-btn';\n    clearBtn.id = 'scan-clear-image';\n    clearBtn.setAttribute('aria-label', 'Clear image');\n    clearBtn.textContent = '✕';\n\n    wrapper.appendChild(img);\n    wrapper.appendChild(clearBtn);\n    previewContainer.appendChild(wrapper);\n\n    previewContainer.style.display = 'block';\n\n    // Show auto-detect button\n    const autoDetectArea = document.getElementById('scan-auto-detect-area');\n    if (autoDetectArea) {\n        autoDetectArea.style.display = 'block';\n    }\n\n    // Attach clear button listener using centralized event manager for cleanup\n    eventListenerManager.add(clearBtn, 'click', onClearImage);\n}\n\n/**\n * Clear uploaded image display and hide related areas\n */\nexport function clearImageDisplay(): void {\n    const previewContainer = document.getElementById('scan-image-preview');\n    if (previewContainer) {\n        previewContainer.innerHTML = '';\n        previewContainer.style.display = 'none';\n    }\n\n    const selectionContainer = document.getElementById('scan-selection-area');\n    if (selectionContainer) {\n        selectionContainer.style.display = 'none';\n    }\n\n    const autoDetectArea = document.getElementById('scan-auto-detect-area');\n    if (autoDetectArea) {\n        autoDetectArea.style.display = 'none';\n    }\n\n    const detectionInfo = document.getElementById('scan-detection-info');\n    if (detectionInfo) {\n        detectionInfo.style.display = 'none';\n    }\n\n    // Clear file input\n    const fileInput = document.getElementById('scan-file-input') as HTMLInputElement;\n    if (fileInput) {\n        fileInput.value = '';\n    }\n}\n\n/**\n * Show item selection grid\n */\nexport function showItemSelectionGrid(\n    allData: AllGameData,\n    onCharacterSelect: (character: Character) => void,\n    onWeaponSelect: (weapon: Weapon) => void,\n    onItemCountChange: ItemCountUpdateCallback,\n    onTomeToggle: (tome: Tome, selected: boolean) => void,\n    updateSummary: () => void\n): void {\n    const selectionContainer = document.getElementById('scan-selection-area');\n    if (!selectionContainer) return;\n\n    selectionContainer.style.display = 'block';\n\n    // Create character/weapon selection\n    createEntitySelection('character', allData.characters?.characters || [], entity => {\n        onCharacterSelect(entity as Character);\n        updateSummary();\n    });\n    createEntitySelection('weapon', allData.weapons?.weapons || [], entity => {\n        onWeaponSelect(entity as Weapon);\n        updateSummary();\n    });\n\n    // Create item selection grid\n    createItemGrid(allData, onItemCountChange, updateSummary);\n\n    // Create tome selection grid\n    createTomeGrid(allData, onTomeToggle, updateSummary);\n\n    // Update summary\n    updateSummary();\n}\n\n/**\n * Create entity selection (character/weapon)\n */\nfunction createEntitySelection(\n    type: 'character' | 'weapon',\n    entities: (Character | Weapon)[],\n    onSelect: (entity: Character | Weapon) => void\n): void {\n    const container = document.getElementById(`scan-${type}-grid`);\n    if (!container) return;\n\n    container.innerHTML = '';\n\n    entities.forEach((entity: Character | Weapon) => {\n        const card = document.createElement('button');\n        card.className = 'scan-entity-card';\n        card.dataset.id = entity.id;\n        card.innerHTML = `\n            <div class=\"scan-entity-name\">${escapeHtml(entity.name)}</div>\n            <div class=\"scan-entity-tier tier-${escapeHtml(entity.tier.toLowerCase())}\">${escapeHtml(entity.tier)}</div>\n        `;\n\n        card.addEventListener('click', () => {\n            // Deselect all others\n            container.querySelectorAll('.scan-entity-card').forEach(c => c.classList.remove('selected'));\n            // Select this one\n            card.classList.add('selected');\n            onSelect(entity);\n        });\n\n        container.appendChild(card);\n    });\n}\n\n/**\n * Create item selection grid\n */\nfunction createItemGrid(\n    allData: AllGameData,\n    onItemCountChange: ItemCountUpdateCallback,\n    updateSummary: () => void\n): void {\n    const container = document.getElementById('scan-item-grid');\n    if (!container || !allData.items?.items) return;\n\n    container.innerHTML = '';\n\n    // Add search filter\n    const searchBox = document.createElement('input');\n    searchBox.type = 'search';\n    searchBox.className = 'scan-search-input';\n    searchBox.placeholder = '🔍 Search items...';\n    searchBox.addEventListener('input', e => {\n        const query = (e.target as HTMLInputElement).value.toLowerCase();\n        filterItemGrid(query);\n    });\n    container.appendChild(searchBox);\n\n    // Create grid container\n    const gridContainer = document.createElement('div');\n    gridContainer.className = 'scan-grid-items';\n    gridContainer.id = 'scan-grid-items-container';\n\n    allData.items.items.forEach(item => {\n        const card = createItemCard(item, onItemCountChange, updateSummary);\n        gridContainer.appendChild(card);\n    });\n\n    container.appendChild(gridContainer);\n}\n\n/**\n * Create individual item card\n */\nfunction createItemCard(\n    item: Item,\n    onItemCountChange: ItemCountUpdateCallback,\n    updateSummary: () => void\n): HTMLElement {\n    const card = document.createElement('div');\n    card.className = 'scan-item-card';\n    card.dataset.id = item.id;\n    card.dataset.name = item.name.toLowerCase();\n\n    // Item info\n    const info = document.createElement('div');\n    info.className = 'scan-item-info';\n    info.innerHTML = `\n        <div class=\"scan-item-name\">${escapeHtml(item.name)}</div>\n        <div class=\"scan-item-tier tier-${escapeHtml(item.tier.toLowerCase())}\">${escapeHtml(item.tier)}</div>\n    `;\n\n    // Counter controls\n    const controls = document.createElement('div');\n    controls.className = 'scan-item-controls';\n\n    const decrementBtn = document.createElement('button');\n    decrementBtn.className = 'scan-count-btn';\n    decrementBtn.textContent = '−';\n    decrementBtn.setAttribute('aria-label', `Decrease ${item.name} count`);\n\n    const countDisplay = document.createElement('span');\n    countDisplay.className = 'scan-count-display';\n    countDisplay.textContent = '0';\n\n    const incrementBtn = document.createElement('button');\n    incrementBtn.className = 'scan-count-btn';\n    incrementBtn.textContent = '+';\n    incrementBtn.setAttribute('aria-label', `Increase ${item.name} count`);\n\n    const updateCount = (delta: number) => {\n        const newCount = onItemCountChange(item, delta);\n        countDisplay.textContent = newCount.toString();\n        if (newCount === 0) {\n            card.classList.remove('selected');\n        } else {\n            card.classList.add('selected');\n        }\n        updateSummary();\n    };\n\n    decrementBtn.addEventListener('click', () => updateCount(-1));\n    incrementBtn.addEventListener('click', () => updateCount(1));\n\n    controls.appendChild(decrementBtn);\n    controls.appendChild(countDisplay);\n    controls.appendChild(incrementBtn);\n\n    card.appendChild(info);\n    card.appendChild(controls);\n\n    return card;\n}\n\n/**\n * Filter item grid by search query\n */\nexport function filterItemGrid(query: string): void {\n    const gridContainer = document.getElementById('scan-grid-items-container');\n    if (!gridContainer) return;\n\n    const cards = gridContainer.querySelectorAll('.scan-item-card');\n    cards.forEach(card => {\n        const name = (card as HTMLElement).dataset.name || '';\n        if (name.includes(query)) {\n            (card as HTMLElement).style.display = 'flex';\n        } else {\n            (card as HTMLElement).style.display = 'none';\n        }\n    });\n}\n\n/**\n * Create tome selection grid\n */\nfunction createTomeGrid(\n    allData: AllGameData,\n    onTomeToggle: (tome: Tome, selected: boolean) => void,\n    updateSummary: () => void\n): void {\n    const container = document.getElementById('scan-tome-grid');\n    if (!container || !allData.tomes?.tomes) return;\n\n    container.innerHTML = '';\n\n    allData.tomes.tomes.forEach(tome => {\n        const card = document.createElement('button');\n        card.className = 'scan-tome-card';\n        card.dataset.id = tome.id;\n        card.innerHTML = `\n            <div class=\"scan-tome-name\">${escapeHtml(tome.name)}</div>\n            <div class=\"scan-tome-tier tier-${escapeHtml(tome.tier.toLowerCase())}\">${escapeHtml(tome.tier)}</div>\n        `;\n\n        card.addEventListener('click', () => {\n            const isSelected = card.classList.contains('selected');\n            if (isSelected) {\n                card.classList.remove('selected');\n                onTomeToggle(tome, false);\n            } else {\n                card.classList.add('selected');\n                onTomeToggle(tome, true);\n            }\n            updateSummary();\n        });\n\n        container.appendChild(card);\n    });\n}\n\n/**\n * Highlight detected entity in the grid\n */\nexport function highlightDetectedEntity(type: 'character' | 'weapon' | 'tome', entityId: string): void {\n    let gridId = '';\n    switch (type) {\n        case 'character':\n            gridId = 'scan-character-grid';\n            break;\n        case 'weapon':\n            gridId = 'scan-weapon-grid';\n            break;\n        case 'tome':\n            gridId = 'scan-tome-grid';\n            break;\n    }\n\n    const grid = document.getElementById(gridId);\n    if (!grid) return;\n\n    // Remove existing selections\n    grid.querySelectorAll('.scan-entity-card, .scan-tome-card').forEach(card => {\n        card.classList.remove('selected');\n    });\n\n    // Add selection to detected entity\n    const card = grid.querySelector(`[data-id=\"${entityId}\"]`);\n    if (card) {\n        card.classList.add('selected');\n    }\n}\n\n/**\n * Update item card count display\n */\nexport function updateItemCardCount(itemId: string, count: number): void {\n    const gridContainer = document.getElementById('scan-grid-items-container');\n    if (!gridContainer) return;\n\n    const card = gridContainer.querySelector(`[data-id=\"${itemId}\"]`);\n    if (!card) return;\n\n    const countDisplay = card.querySelector('.scan-count-display');\n    if (countDisplay) {\n        countDisplay.textContent = count.toString();\n    }\n\n    card.classList.add('selected');\n}\n\n/**\n * Update selection summary display\n */\nexport function updateSelectionSummary(state: SelectionState): void {\n    const summaryContainer = document.getElementById('scan-selection-summary');\n    if (!summaryContainer) return;\n\n    let html = '<h4>Selected Build State:</h4>';\n\n    // Character\n    if (state.selectedCharacter) {\n        html += `<div class=\"scan-summary-item\">👤 <strong>${escapeHtml(state.selectedCharacter.name)}</strong></div>`;\n    }\n\n    // Weapon\n    if (state.selectedWeapon) {\n        html += `<div class=\"scan-summary-item\">⚔️ <strong>${escapeHtml(state.selectedWeapon.name)}</strong></div>`;\n    }\n\n    // Items\n    if (state.selectedItems.size > 0) {\n        html += '<div class=\"scan-summary-section\"><strong>📦 Items:</strong><ul>';\n        state.selectedItems.forEach(({ item, count }) => {\n            html += `<li>${escapeHtml(item.name)} x${count}</li>`;\n        });\n        html += '</ul></div>';\n    }\n\n    // Tomes\n    if (state.selectedTomes.size > 0) {\n        html += '<div class=\"scan-summary-section\"><strong>📚 Tomes:</strong><ul>';\n        state.selectedTomes.forEach(tome => {\n            html += `<li>${escapeHtml(tome.name)}</li>`;\n        });\n        html += '</ul></div>';\n    }\n\n    summaryContainer.innerHTML = html;\n\n    // Show/hide apply button\n    const applyBtn = document.getElementById('scan-apply-to-advisor');\n    if (applyBtn) {\n        applyBtn.style.display =\n            state.selectedCharacter || state.selectedWeapon || state.selectedItems.size > 0 || state.selectedTomes.size > 0\n                ? 'block'\n                : 'none';\n    }\n}\n","// ========================================\n// MegaBonk Scan Build - Detection Module\n// ========================================\n// Handles OCR, CV, and hybrid detection\n// ========================================\n\nimport { ToastManager } from './toast.ts';\nimport { logger } from './logger.ts';\nimport { autoDetectFromImage, type DetectionResult } from './ocr/index.ts';\nimport {\n    detectItemsWithCV,\n    combineDetections,\n    aggregateDuplicates,\n    createDebugOverlay,\n} from './computer-vision.ts';\nimport { setLastOverlayUrl, updateStats, updateLogViewer, isDebugEnabled } from './debug-ui.ts';\nimport { createProgressIndicator } from './dom-utils.ts';\nimport { logError, logWarning } from './error-utils.ts';\nimport type { Mutex } from './async-utils.ts';\n\n// Re-export DetectionResult for consumers\nexport type { DetectionResult };\n\n/**\n * Result structure from detection operations\n */\nexport interface DetectionResults {\n    items: DetectionResult[];\n    tomes: DetectionResult[];\n    character: DetectionResult | null;\n    weapon: DetectionResult | null;\n}\n\n/**\n * Combine OCR and CV detection results into unified hybrid results\n */\nexport function combineHybridResults(\n    ocrResults: Awaited<ReturnType<typeof autoDetectFromImage>>,\n    cvResults: Awaited<ReturnType<typeof detectItemsWithCV>>\n): DetectionResults & { rawText: string } {\n    // Convert CV results to OCR format\n    const cvAsOCR: DetectionResult[] = cvResults.map(cv => ({\n        type: cv.type,\n        entity: cv.entity,\n        confidence: cv.confidence,\n        rawText: `cv_detected_${cv.entity.name}`,\n    }));\n\n    // Combine and aggregate items\n    const combinedItems = combineDetections(\n        [...ocrResults.items, ...cvAsOCR.filter(r => r.type === 'item')],\n        cvResults.filter(r => r.type === 'item')\n    );\n    const combinedTomes = combineDetections(\n        [...ocrResults.tomes, ...cvAsOCR.filter(r => r.type === 'tome')],\n        cvResults.filter(r => r.type === 'tome')\n    );\n\n    const aggregatedItems = aggregateDuplicates(combinedItems);\n    const aggregatedTomes = aggregateDuplicates(combinedTomes);\n\n    // Determine character (OCR takes priority, fallback to CV)\n    let character: DetectionResult | null = ocrResults.character;\n    if (!character) {\n        const charResult = cvResults.find(r => r.type === 'character');\n        if (charResult) {\n            character = {\n                type: 'character' as const,\n                entity: charResult.entity,\n                confidence: charResult.confidence,\n                rawText: 'hybrid_cv',\n            };\n        }\n    }\n\n    // Determine weapon (OCR takes priority, fallback to CV)\n    let weapon: DetectionResult | null = ocrResults.weapon;\n    if (!weapon) {\n        const weaponResult = cvResults.find(r => r.type === 'weapon');\n        if (weaponResult) {\n            weapon = {\n                type: 'weapon' as const,\n                entity: weaponResult.entity,\n                confidence: weaponResult.confidence,\n                rawText: 'hybrid_cv',\n            };\n        }\n    }\n\n    return {\n        items: aggregatedItems.map(r => ({\n            type: r.type as 'item',\n            entity: r.entity,\n            confidence: r.confidence,\n            rawText: `hybrid_${r.method}`,\n            count: r.count,\n        })),\n        tomes: aggregatedTomes.map(r => ({\n            type: r.type as 'tome',\n            entity: r.entity,\n            confidence: r.confidence,\n            rawText: `hybrid_${r.method}`,\n            count: r.count,\n        })),\n        character,\n        weapon,\n        rawText: 'hybrid_detection',\n    };\n}\n\n/**\n * Display debug overlay if debug mode is enabled\n */\nexport async function displayDebugOverlay(\n    image: string,\n    cvResults: Awaited<ReturnType<typeof detectItemsWithCV>>,\n    hybridResults: { items: DetectionResult[]; tomes: DetectionResult[] }\n): Promise<void> {\n    if (isDebugEnabled()) {\n        const debugOverlayUrl = await createDebugOverlay(image, cvResults);\n        setLastOverlayUrl(debugOverlayUrl);\n\n        const imagePreview = document.getElementById('scan-image-preview');\n        if (imagePreview) {\n            imagePreview.innerHTML = `\n                <img src=\"${debugOverlayUrl}\" alt=\"Debug Overlay\" style=\"max-width: 100%; border-radius: 8px;\" />\n                <p style=\"text-align: center; margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;\">\n                    Debug Mode: Green=High confidence, Orange=Medium, Red=Low\n                </p>\n            `;\n        }\n        ToastManager.success(\n            `Hybrid Detection: ${hybridResults.items.length} items, ${hybridResults.tomes.length} tomes (Debug overlay shown)`\n        );\n    } else {\n        setLastOverlayUrl(null);\n        ToastManager.success(\n            `Hybrid Detection: ${hybridResults.items.length} items, ${hybridResults.tomes.length} tomes (Enhanced accuracy!)`\n        );\n    }\n}\n\n/**\n * Handle auto-detect (OCR only) with CV fallback\n */\nexport async function runAutoDetect(\n    uploadedImage: string,\n    detectionMutex: Mutex,\n    onResults: (results: DetectionResults) => void\n): Promise<void> {\n    // Race condition fix: Prevent concurrent detection runs using mutex\n    if (!detectionMutex.tryAcquire()) {\n        ToastManager.info('Detection already in progress...');\n        return;\n    }\n\n    // Create progress indicator before try block to ensure cleanup in finally\n    const progress = createProgressIndicator('Initializing...');\n    const previewContainer = document.getElementById('scan-image-preview');\n    if (previewContainer) {\n        previewContainer.appendChild(progress.element);\n    }\n\n    try {\n        ToastManager.info('Starting auto-detection...');\n\n        // Run OCR\n        const results = await autoDetectFromImage(uploadedImage, (pct, status) => {\n            progress.update(pct, status);\n        });\n\n        // If OCR found nothing, try CV as fallback\n        if (results.items.length === 0 && results.tomes.length === 0) {\n            logger.info({\n                operation: 'scan_build.ocr_empty_trying_cv',\n                data: { message: 'OCR found no items, trying icon detection' },\n            });\n\n            progress.update(50, 'Trying icon detection...');\n            ToastManager.info('No text found, trying icon detection...');\n\n            try {\n                const cvResults = await detectItemsWithCV(uploadedImage, (pct, status) => {\n                    progress.update(50 + pct * 0.5, status);\n                });\n\n                if (cvResults.length > 0) {\n                    // Convert CV results to detection format\n                    const cvItems = cvResults\n                        .filter(r => r.type === 'item')\n                        .map(r => ({\n                            type: 'item' as const,\n                            entity: r.entity,\n                            confidence: r.confidence,\n                            rawText: `cv_detected_${r.entity.name}`,\n                        }));\n\n                    onResults({\n                        items: cvItems,\n                        tomes: [],\n                        character: null,\n                        weapon: null,\n                    });\n\n                    ToastManager.success(`Detected ${cvResults.length} items via icon matching`);\n\n                    logger.info({\n                        operation: 'scan_build.cv_fallback_success',\n                        data: { itemsDetected: cvResults.length },\n                    });\n                    return;\n                }\n            } catch (cvError) {\n                logWarning('scan_build.cv_fallback_failed', cvError);\n            }\n        }\n\n        // Apply detected items\n        onResults(results);\n\n        if (results.items.length === 0 && results.tomes.length === 0) {\n            ToastManager.info('No items detected. Try Hybrid mode or a clearer screenshot.');\n        } else {\n            ToastManager.success(\n                `Detected: ${results.items.length} items, ${results.tomes.length} tomes` +\n                    (results.character ? ', 1 character' : '') +\n                    (results.weapon ? ', 1 weapon' : '')\n            );\n        }\n\n        logger.info({\n            operation: 'scan_build.auto_detect_complete',\n            data: {\n                itemsDetected: results.items.length,\n                tomesDetected: results.tomes.length,\n                characterDetected: results.character ? 1 : 0,\n                weaponDetected: results.weapon ? 1 : 0,\n            },\n        });\n    } catch (error) {\n        logError('scan_build.auto_detect_error', error);\n        ToastManager.error(`Auto-detection failed: ${(error as Error).message}`);\n    } finally {\n        // Always clean up progress indicator and release lock\n        progress.remove();\n        detectionMutex.release();\n    }\n}\n\n/**\n * Handle hybrid detect (OCR + CV)\n */\nexport async function runHybridDetect(\n    uploadedImage: string,\n    detectionMutex: Mutex,\n    templatesLoaded: boolean,\n    templatesLoadError: Error | null,\n    onResults: (results: DetectionResults) => void\n): Promise<void> {\n    if (!detectionMutex.tryAcquire()) {\n        ToastManager.info('Detection already in progress...');\n        return;\n    }\n\n    if (!templatesLoaded && !templatesLoadError) {\n        ToastManager.info('Item templates are still loading. Please wait a moment and try again.');\n        detectionMutex.release();\n        return;\n    }\n\n    if (templatesLoadError) {\n        ToastManager.warning('Item templates failed to load. Detection accuracy may be reduced.');\n        logWarning('scan_build.hybrid_detect_degraded', templatesLoadError);\n    }\n\n    const progress = createProgressIndicator('Initializing...');\n    const previewContainer = document.getElementById('scan-image-preview');\n    if (previewContainer) {\n        previewContainer.appendChild(progress.element);\n    }\n\n    try {\n        ToastManager.info('Starting hybrid detection (OCR + Computer Vision)...');\n\n        // Run OCR phase\n        progress.update(10, 'Running OCR...');\n        const ocrResults = await autoDetectFromImage(uploadedImage, (pct, status) => {\n            progress.update(10 + pct * 0.4, status);\n        });\n\n        // Run CV phase\n        progress.update(50, 'Running computer vision...');\n        const cvResults = await detectItemsWithCV(uploadedImage, (pct, status) => {\n            progress.update(50 + pct * 0.4, status);\n        });\n\n        // Combine results\n        progress.update(90, 'Combining detections...');\n        const hybridResults = combineHybridResults(ocrResults, cvResults);\n\n        onResults(hybridResults);\n        updateStats();\n        updateLogViewer();\n\n        await displayDebugOverlay(uploadedImage, cvResults, hybridResults);\n\n        logger.info({\n            operation: 'scan_build.hybrid_detect_complete',\n            data: {\n                itemsDetected: hybridResults.items.length,\n                tomesDetected: hybridResults.tomes.length,\n                characterDetected: hybridResults.character ? 1 : 0,\n                weaponDetected: hybridResults.weapon ? 1 : 0,\n                ocrItems: ocrResults.items.length,\n                cvItems: cvResults.length,\n            },\n        });\n    } catch (error) {\n        logError('scan_build.hybrid_detect_error', error);\n        ToastManager.error(`Hybrid detection failed: ${(error as Error).message}`);\n    } finally {\n        progress.remove();\n        detectionMutex.release();\n    }\n}\n","// ========================================\n// MegaBonk Scan Build - Results Module\n// ========================================\n// Handles result processing, display, selection management\n// ========================================\n\nimport type { Item, Tome, Character, Weapon, AllGameData } from '../types/index.ts';\nimport type { DetectionResult } from './ocr/index.ts';\nimport { ToastManager } from './toast.ts';\nimport { logger } from './logger.ts';\nimport { escapeHtml } from './utils.ts';\nimport { highlightDetectedEntity, updateItemCardCount } from './scan-build-ui.ts';\nimport type { SelectionState } from './scan-build-ui.ts';\n\n/**\n * Detection results structure\n */\nexport interface DetectionResults {\n    items: DetectionResult[];\n    tomes: DetectionResult[];\n    character: DetectionResult | null;\n    weapon: DetectionResult | null;\n}\n\n/**\n * Get confidence class based on confidence level\n */\nexport function getConfidenceClass(confidence: number): string {\n    if (confidence >= 0.8) return 'confidence-high';\n    if (confidence >= 0.5) return 'confidence-medium';\n    return 'confidence-low';\n}\n\n/**\n * Display detection confidence information\n */\nexport function displayDetectionConfidence(results: DetectionResults): void {\n    const container = document.getElementById('scan-detection-info');\n    if (!container) return;\n\n    // Count detections by confidence level\n    const allDetections: DetectionResult[] = [\n        ...(results.character ? [results.character] : []),\n        ...(results.weapon ? [results.weapon] : []),\n        ...results.items,\n        ...results.tomes,\n    ];\n\n    const highCount = allDetections.filter(d => d.confidence >= 0.8).length;\n    const mediumCount = allDetections.filter(d => d.confidence >= 0.5 && d.confidence < 0.8).length;\n    const lowCount = allDetections.filter(d => d.confidence < 0.5).length;\n    const avgConfidence =\n        allDetections.length > 0 ? allDetections.reduce((sum, d) => sum + d.confidence, 0) / allDetections.length : 0;\n\n    let html = '<div class=\"scan-detection-results\"><h4>🔍 Detection Confidence:</h4>';\n\n    // Stats summary\n    if (allDetections.length > 0) {\n        html += `<div class=\"scan-detection-stats\">\n            <div class=\"scan-detection-stat stat-high\">\n                <span class=\"stat-count\">${highCount}</span> high\n            </div>\n            <div class=\"scan-detection-stat stat-medium\">\n                <span class=\"stat-count\">${mediumCount}</span> medium\n            </div>\n            <div class=\"scan-detection-stat stat-low\">\n                <span class=\"stat-count\">${lowCount}</span> low\n            </div>\n            <div class=\"scan-detection-stat\">\n                Avg: <span class=\"stat-count\">${Math.round(avgConfidence * 100)}%</span>\n            </div>\n        </div>`;\n    }\n\n    // Low confidence warning\n    if (lowCount >= 3 || (lowCount > 0 && lowCount >= allDetections.length * 0.5)) {\n        html += `<div class=\"scan-low-confidence-warning\">\n            <strong>⚠️ Many low-confidence detections</strong>\n            Some items may be incorrectly identified. Review the selections below and adjust as needed.\n        </div>`;\n    }\n\n    if (results.character) {\n        const confClass = getConfidenceClass(results.character.confidence);\n        html += `<div class=\"scan-detection-item\">\n            <span>Character: ${escapeHtml(results.character.entity.name)}</span>\n            <span class=\"confidence ${confClass}\">${Math.round(results.character.confidence * 100)}%</span>\n        </div>`;\n    }\n\n    if (results.weapon) {\n        const confClass = getConfidenceClass(results.weapon.confidence);\n        html += `<div class=\"scan-detection-item\">\n            <span>Weapon: ${escapeHtml(results.weapon.entity.name)}</span>\n            <span class=\"confidence ${confClass}\">${Math.round(results.weapon.confidence * 100)}%</span>\n        </div>`;\n    }\n\n    if (results.items.length > 0) {\n        html += '<div class=\"scan-detection-section\"><strong>Items:</strong>';\n        results.items.forEach(item => {\n            const confClass = getConfidenceClass(item.confidence);\n            html += `<div class=\"scan-detection-item\">\n                <span>${escapeHtml(item.entity.name)}</span>\n                <span class=\"confidence ${confClass}\">${Math.round(item.confidence * 100)}%</span>\n            </div>`;\n        });\n        html += '</div>';\n    }\n\n    if (results.tomes.length > 0) {\n        html += '<div class=\"scan-detection-section\"><strong>Tomes:</strong>';\n        results.tomes.forEach(tome => {\n            const confClass = getConfidenceClass(tome.confidence);\n            html += `<div class=\"scan-detection-item\">\n                <span>${escapeHtml(tome.entity.name)}</span>\n                <span class=\"confidence ${confClass}\">${Math.round(tome.confidence * 100)}%</span>\n            </div>`;\n        });\n        html += '</div>';\n    }\n\n    html += '<p class=\"scan-detection-hint\">💡 Review and adjust selections below if needed</p></div>';\n    container.innerHTML = html;\n    container.style.display = 'block';\n}\n\n/**\n * Apply detection results to the state and UI\n */\nexport function applyDetectionResults(\n    results: DetectionResults,\n    allData: AllGameData,\n    state: SelectionState,\n    showGrid: () => void,\n    updateSummary: () => void\n): void {\n    // Clear existing selections\n    state.selectedItems.clear();\n    state.selectedTomes.clear();\n    state.selectedCharacter = null;\n    state.selectedWeapon = null;\n\n    // Show selection grid\n    showGrid();\n\n    // Apply character\n    if (results.character) {\n        state.selectedCharacter = results.character.entity as Character;\n        highlightDetectedEntity('character', results.character.entity.id);\n    }\n\n    // Apply weapon\n    if (results.weapon) {\n        state.selectedWeapon = results.weapon.entity as Weapon;\n        highlightDetectedEntity('weapon', results.weapon.entity.id);\n    }\n\n    // Apply items (deduplicate and count)\n    const itemCounts = new Map<string, number>();\n    results.items.forEach(detection => {\n        // Bug fix: Check detection.entity exists before accessing .id\n        if (!detection.entity) return;\n        const item = detection.entity as Item;\n        const currentCount = itemCounts.get(item.id) || 0;\n        itemCounts.set(item.id, currentCount + 1);\n    });\n\n    itemCounts.forEach((count, itemId) => {\n        // Bug fix: Use optional chaining on .find() to prevent TypeError if items array is undefined\n        const item = allData.items?.items?.find(i => i.id === itemId);\n        if (item) {\n            state.selectedItems.set(item.id, { item, count });\n            updateItemCardCount(item.id, count);\n        }\n    });\n\n    // Apply tomes (unique)\n    const uniqueTomes = new Set<string>();\n    results.tomes.forEach(detection => {\n        // Bug fix: Check detection.entity exists before accessing .id\n        if (!detection.entity) return;\n        const tome = detection.entity as Tome;\n        if (!uniqueTomes.has(tome.id)) {\n            uniqueTomes.add(tome.id);\n            state.selectedTomes.set(tome.id, tome);\n            highlightDetectedEntity('tome', tome.id);\n        }\n    });\n\n    // Update summary\n    updateSummary();\n\n    // Show detection confidence info\n    displayDetectionConfidence(results);\n}\n\n/**\n * Build state for advisor\n */\nexport interface BuildState {\n    character: Character | null;\n    weapon: Weapon | null;\n    items: Item[];\n    tomes: Tome[];\n}\n\n/**\n * Apply selections to the main advisor\n */\nexport function applyToAdvisor(\n    state: SelectionState,\n    onBuildStateChange: ((state: BuildState) => void) | null\n): void {\n    // Convert items map to array (expand counts)\n    const items: Item[] = [];\n    state.selectedItems.forEach(({ item, count }) => {\n        for (let i = 0; i < count; i++) {\n            items.push(item);\n        }\n    });\n\n    const buildState: BuildState = {\n        character: state.selectedCharacter,\n        weapon: state.selectedWeapon,\n        items,\n        tomes: Array.from(state.selectedTomes.values()),\n    };\n\n    // Use callback if provided\n    if (onBuildStateChange) {\n        onBuildStateChange(buildState);\n    }\n\n    // Also call the global applyScannedBuild function if available\n    // Use typed window lookup for better type safety\n    const windowWithApply = window as Window & {\n        applyScannedBuild?: (state: BuildState) => void;\n    };\n    if (typeof windowWithApply.applyScannedBuild === 'function') {\n        windowWithApply.applyScannedBuild(buildState);\n    }\n\n    ToastManager.success('Build state applied to advisor!');\n\n    logger.info({\n        operation: 'scan_build.applied_to_advisor',\n        data: {\n            character: state.selectedCharacter?.name,\n            weapon: state.selectedWeapon?.name,\n            itemsCount: items.length,\n            tomesCount: buildState.tomes.length,\n        },\n    });\n\n    // Scroll to advisor section\n    setTimeout(() => {\n        const advisorSection = document.getElementById('advisor-current-build-section');\n        advisorSection?.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }, 100);\n}\n\n/**\n * Scan state return type\n */\nexport interface ScanState {\n    character: Character | null;\n    weapon: Weapon | null;\n    items: Array<{ id: string; name: string; count: number }>;\n    tomes: Array<{ id: string; name: string }>;\n}\n\n/**\n * Get current scan state\n */\nexport function getScanState(state: SelectionState): ScanState {\n    return {\n        character: state.selectedCharacter,\n        weapon: state.selectedWeapon,\n        items: Array.from(state.selectedItems.entries()).map(([id, data]) => ({\n            id,\n            name: data.item.name,\n            count: data.count,\n        })),\n        tomes: Array.from(state.selectedTomes.values()).map(t => ({ id: t.id, name: t.name })),\n    };\n}\n","// ========================================\n// MegaBonk Scan Build Module\n// ========================================\n// Main entry point - orchestrates scan build functionality\n// Handles image upload, state management, and coordinates sub-modules\n// ========================================\n\nimport type { Item, Tome, AllGameData, Character, Weapon } from '../types/index.ts';\nimport { ToastManager } from './toast.ts';\nimport { logger } from './logger.ts';\nimport { initOCR } from './ocr/index.ts';\nimport { initCV, loadItemTemplates } from './computer-vision.ts';\nimport { MAX_FILE_SIZE_BYTES } from './constants.ts';\nimport { MAX_ITEM_COUNT } from './constants.ts';\nimport { createMutex, createDebouncedAsync } from './async-utils.ts';\nimport { logError } from './error-utils.ts';\nimport { createEventListenerManager } from './dom-utils.ts';\n\n// Import from sub-modules\nimport {\n    displayUploadedImage,\n    clearImageDisplay,\n    showItemSelectionGrid,\n    updateSelectionSummary,\n    type SelectionState,\n} from './scan-build-ui.ts';\nimport { runAutoDetect, runHybridDetect, type DetectionResults } from './scan-build-detection.ts';\nimport { applyDetectionResults, applyToAdvisor, getScanState, type ScanState, type BuildState } from './scan-build-results.ts';\n\n// Re-export types for consumers\nexport type { ScanState, BuildState, DetectionResults };\n\n// ========================================\n// State\n// ========================================\nlet allData: AllGameData = {};\nlet uploadedImage: string | null = null;\nlet selectedItems: Map<string, { item: Item; count: number }> = new Map();\nlet selectedTomes: Map<string, Tome> = new Map();\nlet selectedCharacter: Character | null = null;\nlet selectedWeapon: Weapon | null = null;\nlet templatesLoaded: boolean = false;\nlet templatesLoadError: Error | null = null;\n\n// Event listener cleanup - use centralized manager for easy cleanup\nconst eventListenerManager = createEventListenerManager();\n\n// File upload debounce - prevents race conditions from rapid uploads\nconst uploadDebouncer = createDebouncedAsync(processFileUploadAsync, 100);\n\n// Race condition fix: Mutex to prevent concurrent detection runs\n// Without this, multiple button clicks could start overlapping detections\nconst detectionMutex = createMutex('scan_detection');\n\n// Callbacks for when build state is updated\ntype BuildStateCallback = (state: BuildState) => void;\nlet onBuildStateChange: BuildStateCallback | null = null;\n\n// ========================================\n// Helper to get current state\n// ========================================\nfunction getSelectionState(): SelectionState {\n    return {\n        selectedItems,\n        selectedTomes,\n        selectedCharacter,\n        selectedWeapon,\n    };\n}\n\n// ========================================\n// Initialization\n// ========================================\n\n/**\n * Initialize the scan build module with game data\n */\nexport function initScanBuild(gameData: AllGameData, stateChangeCallback?: BuildStateCallback): void {\n    allData = gameData;\n    if (stateChangeCallback) {\n        onBuildStateChange = stateChangeCallback;\n    }\n\n    // Initialize OCR and CV modules\n    initOCR(gameData);\n    initCV(gameData);\n\n    // Preload item templates for template matching\n    // Track loading status for better error handling during detection\n    templatesLoaded = false;\n    templatesLoadError = null;\n\n    // Disable hybrid detect button until templates are loaded\n    const hybridBtn = document.getElementById('scan-hybrid-detect-btn') as HTMLButtonElement | null;\n    if (hybridBtn) {\n        hybridBtn.disabled = true;\n        hybridBtn.title = 'Loading item templates...';\n    }\n\n    loadItemTemplates()\n        .then(() => {\n            templatesLoaded = true;\n            // Re-enable hybrid detect button\n            if (hybridBtn) {\n                hybridBtn.disabled = false;\n                hybridBtn.title = '';\n            }\n            logger.info({\n                operation: 'scan_build.templates_loaded',\n                data: { success: true },\n            });\n        })\n        .catch(error => {\n            templatesLoadError = error as Error;\n            // Re-enable button but show warning state\n            if (hybridBtn) {\n                hybridBtn.disabled = false;\n                hybridBtn.title = 'Templates failed to load - reduced accuracy';\n            }\n            logger.error({\n                operation: 'scan_build.load_templates',\n                error: {\n                    name: (error as Error).name,\n                    message: (error as Error).message,\n                    stack: (error as Error).stack?.split('\\n').slice(0, 5).join(' -> '),\n                },\n                data: {\n                    itemsCount: gameData.items?.items?.length || 0,\n                    phase: 'template_preload',\n                },\n            });\n            ToastManager.error('Failed to load item templates for recognition');\n        });\n\n    setupEventListeners();\n\n    logger.info({\n        operation: 'scan_build.init',\n        data: {\n            itemsCount: gameData.items?.items.length || 0,\n        },\n    });\n}\n\n/**\n * Cleanup event listeners to prevent memory leaks\n */\nexport function cleanupEventListeners(): void {\n    eventListenerManager.removeAll();\n}\n\n// ========================================\n// Event Listeners\n// ========================================\n\n/**\n * Setup event listeners for scan build UI\n * Uses centralized event listener manager for easy cleanup to prevent memory leaks\n */\nfunction setupEventListeners(): void {\n    // Clean up any existing listeners first\n    cleanupEventListeners();\n\n    // Upload/Camera button\n    const uploadBtn = document.getElementById('scan-upload-btn');\n    if (uploadBtn) eventListenerManager.addWithSignal(uploadBtn, 'click', handleUploadClick);\n\n    // File input change\n    const fileInput = document.getElementById('scan-file-input') as HTMLInputElement;\n    if (fileInput) eventListenerManager.addWithSignal(fileInput, 'change', handleFileSelect);\n\n    // Clear image button\n    const clearBtn = document.getElementById('scan-clear-image');\n    if (clearBtn) eventListenerManager.addWithSignal(clearBtn, 'click', clearUploadedImage);\n\n    // Apply to advisor button\n    const applyBtn = document.getElementById('scan-apply-to-advisor');\n    if (applyBtn) eventListenerManager.addWithSignal(applyBtn, 'click', handleApplyToAdvisor);\n\n    // Auto-detect button (OCR)\n    const autoDetectBtn = document.getElementById('scan-auto-detect-btn');\n    if (autoDetectBtn) eventListenerManager.addWithSignal(autoDetectBtn, 'click', handleAutoDetect);\n\n    // Hybrid detect button (OCR + CV)\n    const hybridDetectBtn = document.getElementById('scan-hybrid-detect-btn');\n    if (hybridDetectBtn) eventListenerManager.addWithSignal(hybridDetectBtn, 'click', handleHybridDetect);\n}\n\n// ========================================\n// File Upload Handlers\n// ========================================\n\n/**\n * Handle upload button click - trigger file input\n */\nfunction handleUploadClick(): void {\n    const fileInput = document.getElementById('scan-file-input') as HTMLInputElement;\n    fileInput?.click();\n}\n\n/**\n * Handle file selection with debouncing to prevent race conditions\n */\nasync function handleFileSelect(e: Event): Promise<void> {\n    const input = e.target as HTMLInputElement;\n    const file = input.files?.[0];\n\n    if (!file) return;\n\n    // Validate file type\n    if (!file.type.startsWith('image/')) {\n        ToastManager.error('Please select an image file');\n        return;\n    }\n\n    // Validate file size\n    if (file.size > MAX_FILE_SIZE_BYTES) {\n        ToastManager.error(`Image size must be less than ${MAX_FILE_SIZE_BYTES / (1024 * 1024)}MB`);\n        return;\n    }\n\n    // Debounce file reads to prevent race conditions from rapid uploads\n    uploadDebouncer.call(file);\n}\n\n/**\n * Process file upload after debounce (async version for debouncer)\n * Note: The debouncer handles stale check internally\n */\nasync function processFileUploadAsync(file: File): Promise<void> {\n    return new Promise((resolve, reject) => {\n        try {\n            // Read file as data URL\n            const reader = new FileReader();\n            reader.onload = event => {\n                const result = event.target?.result;\n                if (typeof result === 'string') {\n                    uploadedImage = result;\n                    displayUploadedImage(uploadedImage, eventListenerManager, clearUploadedImage);\n                    showGrid();\n                    ToastManager.success('Image uploaded! Now select the items you see');\n                    resolve();\n                } else {\n                    ToastManager.error('Failed to read image as data URL');\n                    reject(new Error('Failed to read image as data URL'));\n                }\n            };\n            reader.onerror = () => {\n                ToastManager.error('Failed to read image file');\n                reject(new Error('Failed to read image file'));\n            };\n            reader.readAsDataURL(file);\n\n            logger.info({\n                operation: 'scan_build.image_uploaded',\n                data: {\n                    fileName: file.name,\n                    fileSize: file.size,\n                    fileType: file.type,\n                },\n            });\n        } catch (error) {\n            logError('scan_build.upload_error', error);\n            ToastManager.error('Failed to upload image');\n            reject(error);\n        }\n    });\n}\n\n// ========================================\n// State Management\n// ========================================\n\n/**\n * Clear uploaded image and reset state\n */\nfunction clearUploadedImage(): void {\n    uploadedImage = null;\n    selectedItems.clear();\n    selectedTomes.clear();\n    selectedCharacter = null;\n    selectedWeapon = null;\n\n    clearImageDisplay();\n    ToastManager.info('Image cleared');\n}\n\n/**\n * Update item count - called from UI\n */\nfunction handleItemCountChange(item: Item, delta: number): number {\n    const current = selectedItems.get(item.id);\n    const currentCount = current?.count || 0;\n    const newCount = Math.max(0, Math.min(MAX_ITEM_COUNT, currentCount + delta));\n\n    if (newCount === 0) {\n        selectedItems.delete(item.id);\n    } else {\n        selectedItems.set(item.id, { item, count: newCount });\n    }\n\n    return newCount;\n}\n\n/**\n * Handle character selection\n */\nfunction handleCharacterSelect(character: Character): void {\n    selectedCharacter = character;\n}\n\n/**\n * Handle weapon selection\n */\nfunction handleWeaponSelect(weapon: Weapon): void {\n    selectedWeapon = weapon;\n}\n\n/**\n * Handle tome toggle\n */\nfunction handleTomeToggle(tome: Tome, selected: boolean): void {\n    if (selected) {\n        selectedTomes.set(tome.id, tome);\n    } else {\n        selectedTomes.delete(tome.id);\n    }\n}\n\n/**\n * Update the selection summary display\n */\nfunction updateSummary(): void {\n    updateSelectionSummary(getSelectionState());\n}\n\n/**\n * Show the item selection grid\n */\nfunction showGrid(): void {\n    showItemSelectionGrid(\n        allData,\n        handleCharacterSelect,\n        handleWeaponSelect,\n        handleItemCountChange,\n        handleTomeToggle,\n        updateSummary\n    );\n}\n\n// ========================================\n// Detection Handlers\n// ========================================\n\n/**\n * Handle detection results - apply to state and UI\n */\nfunction handleDetectionResults(results: DetectionResults): void {\n    applyDetectionResults(results, allData, getSelectionState(), showGrid, updateSummary);\n}\n\n/**\n * Handle auto-detect button click - use OCR to detect items\n */\nasync function handleAutoDetect(): Promise<void> {\n    if (!uploadedImage) {\n        ToastManager.error('Please upload an image first');\n        return;\n    }\n\n    await runAutoDetect(uploadedImage, detectionMutex, handleDetectionResults);\n}\n\n/**\n * Handle hybrid detect button click - use OCR + CV together\n */\nasync function handleHybridDetect(): Promise<void> {\n    if (!uploadedImage) {\n        ToastManager.error('Please upload an image first');\n        return;\n    }\n\n    await runHybridDetect(\n        uploadedImage,\n        detectionMutex,\n        templatesLoaded,\n        templatesLoadError,\n        handleDetectionResults\n    );\n}\n\n// ========================================\n// Apply to Advisor\n// ========================================\n\n/**\n * Handle apply to advisor button click\n */\nfunction handleApplyToAdvisor(): void {\n    applyToAdvisor(getSelectionState(), onBuildStateChange);\n}\n\n// ========================================\n// Public API\n// ========================================\n\n/**\n * Get current scan state\n */\nexport function getState(): ScanState {\n    return getScanState(getSelectionState());\n}\n\n// Legacy alias for backward compatibility\nexport { getState as getScanState };\n\n/**\n * Reset module state for testing\n */\nexport function __resetForTesting(): void {\n    // Clean up event listeners to prevent memory leaks\n    cleanupEventListeners();\n\n    // Cancel any pending upload debounce\n    uploadDebouncer.cancel();\n\n    // Release mutex if held (should be released, but just in case)\n    if (detectionMutex.isLocked()) {\n        detectionMutex.release();\n    }\n\n    allData = {};\n    uploadedImage = null;\n    selectedItems = new Map();\n    selectedTomes = new Map();\n    selectedCharacter = null;\n    selectedWeapon = null;\n    onBuildStateChange = null;\n    templatesLoaded = false;\n    templatesLoadError = null;\n}\n\n// ========================================\n// Global Assignments\n// ========================================\nwindow.initScanBuild = initScanBuild;\n\n// ========================================\n// Self-Initialization for Lazy Loading\n// ========================================\n// When this module is lazily loaded (e.g., when advisor tab is first visited),\n// data may already be available. Initialize immediately if so.\n// This fixes a race condition where data loads before the module is imported.\n(async function selfInit() {\n    // Dynamic import to avoid circular dependency\n    const { getAllData } = await import('./data-service.ts');\n    const existingData = getAllData();\n\n    // If data is already loaded and we haven't been initialized yet\n    if (existingData && Object.keys(existingData).length > 0 && Object.keys(allData).length === 0) {\n        initScanBuild(existingData);\n        logger.debug({\n            operation: 'scan_build.self_init',\n            data: { itemsCount: existingData.items?.items?.length || 0 },\n        });\n    }\n})();\n","// ========================================\n// MegaBonk Async Utilities Module\n// ========================================\n// Shared async patterns: mutex locks, race condition prevention\n// ========================================\n\n/**\n * Simple mutex lock for preventing race conditions\n * Usage:\n *   const lock = createMutex('myOperation');\n *   if (!lock.tryAcquire()) return; // Already running\n *   try { await doWork(); } finally { lock.release(); }\n */\nexport interface Mutex {\n    /** Check if lock is currently held */\n    isLocked: () => boolean;\n    /** Try to acquire lock. Returns true if acquired, false if already held. */\n    tryAcquire: () => boolean;\n    /** Release the lock */\n    release: () => void;\n    /** Execute function with lock, returning null if lock unavailable */\n    withLock: <T>(fn: () => Promise<T>) => Promise<T | null>;\n}\n\n/**\n * Create a mutex lock for race condition prevention\n * @param _name - Optional name for debugging (reserved for future use)\n * @returns Mutex interface\n */\nexport function createMutex(_name?: string): Mutex {\n    let locked = false;\n\n    return {\n        isLocked: () => locked,\n\n        tryAcquire: () => {\n            if (locked) return false;\n            locked = true;\n            return true;\n        },\n\n        release: () => {\n            locked = false;\n        },\n\n        withLock: async <T>(fn: () => Promise<T>): Promise<T | null> => {\n            if (locked) return null;\n            locked = true;\n            try {\n                return await fn();\n            } finally {\n                locked = false;\n            }\n        },\n    };\n}\n\n/**\n * Create a debounced async function that tracks pending operations\n * Prevents race conditions from rapid calls by ignoring stale results\n * @param fn - Async function to wrap\n * @param delayMs - Debounce delay in milliseconds\n * @returns Wrapped function and cancel method\n */\nexport function createDebouncedAsync<T, Args extends unknown[]>(\n    fn: (...args: Args) => Promise<T>,\n    delayMs: number\n): {\n    call: (...args: Args) => Promise<T | null>;\n    cancel: () => void;\n} {\n    let timeoutId: ReturnType<typeof setTimeout> | null = null;\n    let pendingId = 0;\n\n    return {\n        call: async (...args: Args): Promise<T | null> => {\n            // Cancel any pending call\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n\n            // Increment ID to track this specific call\n            pendingId++;\n            const currentId = pendingId;\n\n            return new Promise((resolve) => {\n                timeoutId = setTimeout(async () => {\n                    // Check if this call is still current\n                    if (currentId !== pendingId) {\n                        resolve(null);\n                        return;\n                    }\n\n                    try {\n                        const result = await fn(...args);\n                        // Double-check after async work\n                        if (currentId === pendingId) {\n                            resolve(result);\n                        } else {\n                            resolve(null);\n                        }\n                    } catch (error) {\n                        // Only propagate if still current\n                        if (currentId === pendingId) {\n                            throw error;\n                        }\n                        resolve(null);\n                    }\n                }, delayMs);\n            });\n        },\n\n        cancel: () => {\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n            pendingId++;\n        },\n    };\n}\n\n/**\n * Create a session tracker for canceling stale async operations\n * Useful for modal/UI state that can change during async work\n * @returns Session tracker interface\n */\nexport interface SessionTracker {\n    /** Get current session ID */\n    getCurrentId: () => number;\n    /** Start a new session, invalidating previous */\n    startNew: () => number;\n    /** Check if given ID is still the current session */\n    isCurrent: (id: number) => boolean;\n    /** Reset to initial state */\n    reset: () => void;\n}\n\nexport function createSessionTracker(): SessionTracker {\n    let currentSessionId = 0;\n\n    return {\n        getCurrentId: () => currentSessionId,\n        startNew: () => ++currentSessionId,\n        isCurrent: (id: number) => id === currentSessionId,\n        reset: () => {\n            currentSessionId = 0;\n        },\n    };\n}\n"],"file":"scan-build-n9q4LD6l.js"}